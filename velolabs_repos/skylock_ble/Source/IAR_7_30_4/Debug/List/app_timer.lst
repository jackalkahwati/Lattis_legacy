###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        16/Apr/2015  21:19:47
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\VeloLabs\SkyLock
#        Project\SDK_7_2_0\components\libraries\timer\app_timer.c
#    Command line =  
#        "C:\VeloLabs\SkyLock
#        Project\SDK_7_2_0\components\libraries\timer\app_timer.c" -D NRF51 -D
#        BLE_STACK_SUPPORT_REQD -lCN "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\Debug\List\" -o "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\Debug\Obj\" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Normal.h" -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\include\" -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\include\ARMFiles\" -I
#        "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\drivers_nrf\hal\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\softdevice\s110\headers\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\toolchain\" -I
#        "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\softdevice\common\softdevice_handler\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\util\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\scheduler\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\timer\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\ble\common\" -Ol
#    List file    =  
#        C:\VeloLabs\SkyLock Project\Source\IAR_7_30_4\Debug\List\app_timer.lst
#    Object file  =  
#        C:\VeloLabs\SkyLock Project\Source\IAR_7_30_4\Debug\Obj\app_timer.o
#
###############################################################################

C:\VeloLabs\SkyLock Project\SDK_7_2_0\components\libraries\timer\app_timer.c
      1          /* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
      2           *
      3           * The information contained herein is property of Nordic Semiconductor ASA.
      4           * Terms and conditions of usage are described in detail in NORDIC
      5           * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
      6           *
      7           * Licensees are granted free, non-transferable use of the information. NO
      8           * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
      9           * the file.
     10           *
     11           */
     12          
     13          #include "app_timer.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp bool is_word_aligned(void *)
   \                     is_word_aligned: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0780             LSLS     R0,R0,#+30
   \   00000004   0xD101             BNE      ??is_word_aligned_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE000             B        ??is_word_aligned_1
   \                     ??is_word_aligned_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??is_word_aligned_1: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0xBD00             POP      {PC}             ;; return
     14          #include <stdlib.h>
     15          #include "nrf51.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000004   0x0EC0             LSRS     R0,R0,#+27
   \   00000006   0x4081             LSLS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable12  ;; 0xe000e100
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000004   0x0EC0             LSRS     R0,R0,#+27
   \   00000006   0x4081             LSLS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable12_1  ;; 0xe000e180
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPendingIRQ(IRQn_Type)
   \                     NVIC_SetPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000004   0x0EC0             LSRS     R0,R0,#+27
   \   00000006   0x4081             LSLS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable12_2  ;; 0xe000e200
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000004   0x0EC0             LSRS     R0,R0,#+27
   \   00000006   0x4081             LSLS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable13  ;; 0xe000e280
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD521             BPL      ??NVIC_SetPriority_0
   \   00000008   0x....             LDR      R3,??DataTable12_3  ;; 0xe000ed1c
   \   0000000A   0xB240             SXTB     R0,R0
   \   0000000C   0x0702             LSLS     R2,R0,#+28       ;; ZeroExtS R2,R0,#+28,#+28
   \   0000000E   0x0F12             LSRS     R2,R2,#+28
   \   00000010   0x3A08             SUBS     R2,R2,#+8
   \   00000012   0x0892             LSRS     R2,R2,#+2
   \   00000014   0x2404             MOVS     R4,#+4
   \   00000016   0x4362             MULS     R2,R4,R2
   \   00000018   0x....             LDR      R4,??DataTable12_3  ;; 0xe000ed1c
   \   0000001A   0xB240             SXTB     R0,R0
   \   0000001C   0x0705             LSLS     R5,R0,#+28       ;; ZeroExtS R5,R0,#+28,#+28
   \   0000001E   0x0F2D             LSRS     R5,R5,#+28
   \   00000020   0x3D08             SUBS     R5,R5,#+8
   \   00000022   0x08AD             LSRS     R5,R5,#+2
   \   00000024   0x2604             MOVS     R6,#+4
   \   00000026   0x4375             MULS     R5,R6,R5
   \   00000028   0x5964             LDR      R4,[R4, R5]
   \   0000002A   0x25FF             MOVS     R5,#+255
   \   0000002C   0x0786             LSLS     R6,R0,#+30       ;; ZeroExtS R6,R0,#+30,#+30
   \   0000002E   0x0FB6             LSRS     R6,R6,#+30
   \   00000030   0x2708             MOVS     R7,#+8
   \   00000032   0x437E             MULS     R6,R7,R6
   \   00000034   0x40B5             LSLS     R5,R5,R6
   \   00000036   0x43AC             BICS     R4,R4,R5
   \   00000038   0x0189             LSLS     R1,R1,#+6
   \   0000003A   0xB2C9             UXTB     R1,R1
   \   0000003C   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000003E   0x0F80             LSRS     R0,R0,#+30
   \   00000040   0x2508             MOVS     R5,#+8
   \   00000042   0x4368             MULS     R0,R5,R0
   \   00000044   0x4081             LSLS     R1,R1,R0
   \   00000046   0x4321             ORRS     R1,R1,R4
   \   00000048   0x5099             STR      R1,[R3, R2]
   \   0000004A   0xE01B             B        ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0: (+1)
   \   0000004C   0x....             LDR      R2,??DataTable14  ;; 0xe000e400
   \   0000004E   0xB240             SXTB     R0,R0
   \   00000050   0x0003             MOVS     R3,R0
   \   00000052   0x089B             LSRS     R3,R3,#+2
   \   00000054   0x2404             MOVS     R4,#+4
   \   00000056   0x4363             MULS     R3,R4,R3
   \   00000058   0x58D2             LDR      R2,[R2, R3]
   \   0000005A   0x23FF             MOVS     R3,#+255
   \   0000005C   0x0784             LSLS     R4,R0,#+30       ;; ZeroExtS R4,R0,#+30,#+30
   \   0000005E   0x0FA4             LSRS     R4,R4,#+30
   \   00000060   0x2508             MOVS     R5,#+8
   \   00000062   0x436C             MULS     R4,R5,R4
   \   00000064   0x40A3             LSLS     R3,R3,R4
   \   00000066   0x439A             BICS     R2,R2,R3
   \   00000068   0x0189             LSLS     R1,R1,#+6
   \   0000006A   0xB2C9             UXTB     R1,R1
   \   0000006C   0x0783             LSLS     R3,R0,#+30       ;; ZeroExtS R3,R0,#+30,#+30
   \   0000006E   0x0F9B             LSRS     R3,R3,#+30
   \   00000070   0x2408             MOVS     R4,#+8
   \   00000072   0x4363             MULS     R3,R4,R3
   \   00000074   0x4099             LSLS     R1,R1,R3
   \   00000076   0x4311             ORRS     R1,R1,R2
   \   00000078   0x....             LDR      R2,??DataTable14  ;; 0xe000e400
   \   0000007A   0xB240             SXTB     R0,R0
   \   0000007C   0x0880             LSRS     R0,R0,#+2
   \   0000007E   0x2304             MOVS     R3,#+4
   \   00000080   0x4358             MULS     R0,R3,R0
   \   00000082   0x5011             STR      R1,[R2, R0]
   \                     ??NVIC_SetPriority_1: (+1)
   \   00000084   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t NVIC_GetPriority(IRQn_Type)
   \                     NVIC_GetPriority: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD512             BPL      ??NVIC_GetPriority_0
   \   00000008   0x....             LDR      R1,??DataTable12_3  ;; 0xe000ed1c
   \   0000000A   0xB240             SXTB     R0,R0
   \   0000000C   0x0702             LSLS     R2,R0,#+28       ;; ZeroExtS R2,R0,#+28,#+28
   \   0000000E   0x0F12             LSRS     R2,R2,#+28
   \   00000010   0x3A08             SUBS     R2,R2,#+8
   \   00000012   0x0892             LSRS     R2,R2,#+2
   \   00000014   0x2304             MOVS     R3,#+4
   \   00000016   0x435A             MULS     R2,R3,R2
   \   00000018   0x5889             LDR      R1,[R1, R2]
   \   0000001A   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000001C   0x0F80             LSRS     R0,R0,#+30
   \   0000001E   0x2208             MOVS     R2,#+8
   \   00000020   0x4350             MULS     R0,R2,R0
   \   00000022   0x40C1             LSRS     R1,R1,R0
   \   00000024   0x0008             MOVS     R0,R1
   \   00000026   0x0980             LSRS     R0,R0,#+6
   \   00000028   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000002A   0x0F80             LSRS     R0,R0,#+30
   \   0000002C   0xE00F             B        ??NVIC_GetPriority_1
   \                     ??NVIC_GetPriority_0: (+1)
   \   0000002E   0x....             LDR      R1,??DataTable14  ;; 0xe000e400
   \   00000030   0xB240             SXTB     R0,R0
   \   00000032   0x0002             MOVS     R2,R0
   \   00000034   0x0892             LSRS     R2,R2,#+2
   \   00000036   0x2304             MOVS     R3,#+4
   \   00000038   0x435A             MULS     R2,R3,R2
   \   0000003A   0x5889             LDR      R1,[R1, R2]
   \   0000003C   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000003E   0x0F80             LSRS     R0,R0,#+30
   \   00000040   0x2208             MOVS     R2,#+8
   \   00000042   0x4350             MULS     R0,R2,R0
   \   00000044   0x40C1             LSRS     R1,R1,R0
   \   00000046   0x0008             MOVS     R0,R1
   \   00000048   0x0980             LSRS     R0,R0,#+6
   \   0000004A   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000004C   0x0F80             LSRS     R0,R0,#+30
   \                     ??NVIC_GetPriority_1: (+1)
   \   0000004E   0xBD00             POP      {PC}             ;; return
     16          #include "nrf51_bitfields.h"
     17          #include "nrf_soc.h"
     18          #include "app_error.h"
     19          #include "nrf_delay.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __interwork __softfp void nrf_delay_us(uint32_t volatile)
   \                     nrf_delay_us: (+1)
   \                     ??loop: (+1)
   \   00000000   0x1E40             SUBS R0, R0, #1
   \   00000002   0xBF00             NOP
   \   00000004   0xBF00             NOP
   \   00000006   0xBF00             NOP
   \   00000008   0xBF00             NOP
   \   0000000A   0xBF00             NOP
   \   0000000C   0xBF00             NOP
   \   0000000E   0xBF00             NOP
   \   00000010   0xBF00             NOP
   \   00000012   0xBF00             NOP
   \   00000014   0xBF00             NOP
   \   00000016   0xBF00             NOP
   \   00000018   0xBF00             NOP
   \   0000001A   0xD1F1             BNE ??loop
   \   0000001C   0x4770             BX       LR               ;; return
     20          #include "app_util.h"
     21          #include "app_util_platform.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t current_int_priority_get(void)
   \                     current_int_priority_get: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x....             LDR      R0,??DataTable15  ;; 0xe000ed04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000008   0x0DC0             LSRS     R0,R0,#+23
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD005             BEQ      ??current_int_priority_get_0
   \   0000000E   0x3810             SUBS     R0,R0,#+16
   \   00000010   0xB240             SXTB     R0,R0
   \   00000012   0x.... 0x....      BL       NVIC_GetPriority
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0xE000             B        ??current_int_priority_get_1
   \                     ??current_int_priority_get_0: (+1)
   \   0000001A   0x2004             MOVS     R0,#+4
   \                     ??current_int_priority_get_1: (+1)
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
     22          
     23          #define RTC1_IRQ_PRI            APP_IRQ_PRIORITY_LOW                        /**< Priority of the RTC1 interrupt (used for checking for timeouts and executing timeout handlers). */
     24          #define SWI0_IRQ_PRI            APP_IRQ_PRIORITY_LOW                        /**< Priority of the SWI0 interrupt (used for updating the timer list). */
     25          
     26          // The current design assumes that both interrupt handlers run at the same interrupt level.
     27          // If this is to be changed, protection must be added to prevent them from interrupting each other
     28          // (e.g. by using guard/trigger flags).
     29          STATIC_ASSERT(RTC1_IRQ_PRI == SWI0_IRQ_PRI);
     30          
     31          #define MAX_RTC_COUNTER_VAL     0x00FFFFFF                                  /**< Maximum value of the RTC counter. */
     32          
     33          #define APP_HIGH_USER_ID        0                                           /**< User Id for the Application High "user". */
     34          #define APP_LOW_USER_ID         1                                           /**< User Id for the Application Low "user". */
     35          #define THREAD_MODE_USER_ID     2                                           /**< User Id for the Thread Mode "user". */
     36          
     37          #define RTC_COMPARE_OFFSET_MIN  3                                           /**< Minimum offset between the current RTC counter value and the Capture Compare register. Although the nRF51 Series User Specification recommends this value to be 2, we use 3 to be safer.*/
     38          
     39          #define MAX_RTC_TASKS_DELAY     47                                          /**< Maximum delay until an RTC task is executed. */
     40          
     41          /**@brief Timer allocation state type. */
     42          typedef enum
     43          {
     44              STATE_FREE,                                                             /**< The timer node is available. */
     45              STATE_ALLOCATED                                                         /**< The timer node has been allocated. */
     46          } timer_alloc_state_t;
     47          
     48          /**@brief Timer node type. The nodes will be used form a linked list of running timers. */
     49          typedef struct
     50          {
     51              timer_alloc_state_t         state;                                      /**< Timer allocation state. */
     52              app_timer_mode_t            mode;                                       /**< Timer mode. */
     53              uint32_t                    ticks_to_expire;                            /**< Number of ticks from previous timer interrupt to timer expiry. */
     54              uint32_t                    ticks_at_start;                             /**< Current RTC counter value when the timer was started. */
     55              uint32_t                    ticks_first_interval;                       /**< Number of ticks in the first timer interval. */
     56              uint32_t                    ticks_periodic_interval;                    /**< Timer period (for repeating timers). */
     57              bool                        is_running;                                 /**< True if timer is running, False otherwise. */
     58              app_timer_timeout_handler_t p_timeout_handler;                          /**< Pointer to function to be executed when the timer expires. */
     59              void *                      p_context;                                  /**< General purpose pointer. Will be passed to the timeout handler when the timer expires. */
     60              app_timer_id_t              next;                                       /**< Id of next timer in list of running timers. */
     61          } timer_node_t;
     62          
     63          STATIC_ASSERT(sizeof(timer_node_t) <= APP_TIMER_NODE_SIZE);
     64          STATIC_ASSERT(sizeof(timer_node_t) % 4 == 0);
     65          
     66          /**@brief Set of available timer operation types. */
     67          typedef enum
     68          {
     69              TIMER_USER_OP_TYPE_NONE,                                                /**< Invalid timer operation type. */
     70              TIMER_USER_OP_TYPE_START,                                               /**< Timer operation type Start. */
     71              TIMER_USER_OP_TYPE_STOP,                                                /**< Timer operation type Stop. */
     72              TIMER_USER_OP_TYPE_STOP_ALL                                             /**< Timer operation type Stop All. */
     73          } timer_user_op_type_t;
     74          
     75          /**@brief Structure describing a timer start operation. */
     76          typedef struct
     77          {
     78              uint32_t ticks_at_start;                                                /**< Current RTC counter value when the timer was started. */
     79              uint32_t ticks_first_interval;                                          /**< Number of ticks in the first timer interval. */
     80              uint32_t ticks_periodic_interval;                                       /**< Timer period (for repeating timers). */
     81              void *   p_context;                                                     /**< General purpose pointer. Will be passed to the timeout handler when the timer expires. */
     82          } timer_user_op_start_t;
     83          
     84          /**@brief Structure describing a timer operation. */
     85          typedef struct
     86          {
     87              timer_user_op_type_t op_type;                                           /**< Timer operation type. */
     88              app_timer_id_t       timer_id;                                          /**< Id of timer on which the operation is to be performed. */
     89              union
     90              {
     91                  timer_user_op_start_t start;                                        /**< Structure describing a timer start operation. */
     92              } params;
     93          } timer_user_op_t;
     94          
     95          STATIC_ASSERT(sizeof(timer_user_op_t) <= APP_TIMER_USER_OP_SIZE);
     96          STATIC_ASSERT(sizeof(timer_user_op_t) % 4 == 0);
     97          
     98          /**@brief Structure describing a timer user.
     99           *
    100           * @details For each user of the timer module, there will be a timer operations queue. This queue
    101           *          will hold timer operations issued by this user until the timer interrupt handler
    102           *          processes these operations. For the current implementation, there will be one user for
    103           *          each interrupt level available to the application (APP_HIGH, APP_LOW and THREAD_MODE),
    104           *          but the module can easily be modified to e.g. have one queue per process when using an
    105           *          RTOS. The purpose of the queues is to be able to have a completely lockless timer
    106           *          implementation.
    107           */
    108          typedef struct
    109          {
    110              uint8_t           first;                                                    /**< Index of first entry to have been inserted in the queue (i.e. the next entry to be executed). */
    111              uint8_t           last;                                                     /**< Index of last entry to have been inserted in the queue. */
    112              uint8_t           user_op_queue_size;                                       /**< Queue size. */
    113              timer_user_op_t * p_user_op_queue;                                          /**< Queue buffer. */
    114          } timer_user_t;
    115          
    116          STATIC_ASSERT(sizeof(timer_user_t) == APP_TIMER_USER_SIZE);
    117          STATIC_ASSERT(sizeof(timer_user_t) % 4 == 0);
    118          
    119          /**@brief User id type.
    120           *
    121           * @details In the current implementation, this will automatically be generated from the current
    122           *          interrupt level.
    123           */
    124          typedef uint32_t timer_user_id_t;
    125          
    126          #define TIMER_NULL                  ((app_timer_id_t)(0 - 1))                   /**< Invalid timer id. */
    127          #define CONTEXT_QUEUE_SIZE_MAX      (2)                                         /**< Timer internal elapsed ticks queue size. */
    128          

   \                                 In section .bss, align 1
    129          static uint8_t                       m_node_array_size;                         /**< Size of timer node array. */
   \                     m_node_array_size:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    130          static timer_node_t *                mp_nodes = NULL;                           /**< Array of timer nodes. */
   \                     mp_nodes:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    131          static uint8_t                       m_user_array_size;                         /**< Size of timer user array. */
   \                     m_user_array_size:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    132          static timer_user_t *                mp_users;                                  /**< Array of timer users. */
   \                     mp_users:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    133          static app_timer_id_t                m_timer_id_head;                           /**< First timer in list of running timers. */
   \                     m_timer_id_head:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    134          static uint32_t                      m_ticks_latest;                            /**< Last known RTC counter value. */
   \                     m_ticks_latest:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    135          static uint32_t                      m_ticks_elapsed[CONTEXT_QUEUE_SIZE_MAX];   /**< Timer internal elapsed ticks queue. */
   \                     m_ticks_elapsed:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
    136          static uint8_t                       m_ticks_elapsed_q_read_ind;                /**< Timer internal elapsed ticks queue read index. */
   \                     m_ticks_elapsed_q_read_ind:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    137          static uint8_t                       m_ticks_elapsed_q_write_ind;               /**< Timer internal elapsed ticks queue write index. */
   \                     m_ticks_elapsed_q_write_ind:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    138          static app_timer_evt_schedule_func_t m_evt_schedule_func;                       /**< Pointer to function for propagating timeout events to the scheduler. */
   \                     m_evt_schedule_func:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    139          static bool                          m_rtc1_running;                            /**< Boolean indicating if RTC1 is running. */
   \                     m_rtc1_running:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    140          static bool                          m_rtc1_reset;                              /**< Boolean indicating if RTC1 counter has been reset due to last timer removed from timer list during the timer list handling. */
   \                     m_rtc1_reset:
   \   00000000                      DS8 1
    141          
    142          
    143          /**@brief Function for initializing the RTC1 counter.
    144           *
    145           * @param[in] prescaler   Value of the RTC1 PRESCALER register. Set to 0 for no prescaling.
    146           */

   \                                 In section .text, align 2, keep-with-next
    147          static void rtc1_init(uint32_t prescaler)
    148          {
   \                     rtc1_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    149              NRF_RTC1->PRESCALER = prescaler;
   \   00000002   0x....             LDR      R1,??DataTable15_1  ;; 0x40011508
   \   00000004   0x6008             STR      R0,[R1, #+0]
    150              NVIC_SetPriority(RTC1_IRQn, RTC1_IRQ_PRI);
   \   00000006   0x2103             MOVS     R1,#+3
   \   00000008   0x2011             MOVS     R0,#+17
   \   0000000A   0x.... 0x....      BL       NVIC_SetPriority
    151          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    152          
    153          
    154          /**@brief Function for starting the RTC1 timer.
    155           */

   \                                 In section .text, align 2, keep-with-next
    156          static void rtc1_start(void)
    157          {
   \                     rtc1_start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    158              NRF_RTC1->EVTENSET = RTC_EVTEN_COMPARE0_Msk;
   \   00000002   0x2080             MOVS     R0,#+128
   \   00000004   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \   00000006   0x....             LDR      R1,??DataTable14_1  ;; 0x40011344
   \   00000008   0x6008             STR      R0,[R1, #+0]
    159              NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE0_Msk;
   \   0000000A   0x2080             MOVS     R0,#+128
   \   0000000C   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \   0000000E   0x....             LDR      R1,??DataTable15_2  ;; 0x40011304
   \   00000010   0x6008             STR      R0,[R1, #+0]
    160          
    161              NVIC_ClearPendingIRQ(RTC1_IRQn);
   \   00000012   0x2011             MOVS     R0,#+17
   \   00000014   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    162              NVIC_EnableIRQ(RTC1_IRQn);
   \   00000018   0x2011             MOVS     R0,#+17
   \   0000001A   0x.... 0x....      BL       NVIC_EnableIRQ
    163          
    164              NRF_RTC1->TASKS_START = 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x....             LDR      R1,??DataTable15_3  ;; 0x40011000
   \   00000022   0x6008             STR      R0,[R1, #+0]
    165              nrf_delay_us(MAX_RTC_TASKS_DELAY);
   \   00000024   0x202F             MOVS     R0,#+47
   \   00000026   0x.... 0x....      BL       nrf_delay_us
    166          
    167              m_rtc1_running = true;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x....             LDR      R1,??DataTable16
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    168          }
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
    169          
    170          
    171          /**@brief Function for stopping the RTC1 timer.
    172           */

   \                                 In section .text, align 2, keep-with-next
    173          static void rtc1_stop(void)
    174          {
   \                     rtc1_stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    175              NVIC_DisableIRQ(RTC1_IRQn);
   \   00000002   0x2011             MOVS     R0,#+17
   \   00000004   0x.... 0x....      BL       NVIC_DisableIRQ
    176          
    177              NRF_RTC1->EVTENCLR = RTC_EVTEN_COMPARE0_Msk;
   \   00000008   0x2080             MOVS     R0,#+128
   \   0000000A   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \   0000000C   0x....             LDR      R1,??DataTable15_4  ;; 0x40011348
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    178              NRF_RTC1->INTENCLR = RTC_INTENSET_COMPARE0_Msk;
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \   00000014   0x....             LDR      R1,??DataTable15_5  ;; 0x40011308
   \   00000016   0x6008             STR      R0,[R1, #+0]
    179          
    180              NRF_RTC1->TASKS_STOP = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x....             LDR      R1,??DataTable15_6  ;; 0x40011004
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    181              nrf_delay_us(MAX_RTC_TASKS_DELAY);
   \   0000001E   0x202F             MOVS     R0,#+47
   \   00000020   0x.... 0x....      BL       nrf_delay_us
    182          
    183              NRF_RTC1->TASKS_CLEAR = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x....             LDR      R1,??DataTable15_7  ;; 0x40011008
   \   00000028   0x6008             STR      R0,[R1, #+0]
    184              m_ticks_latest        = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR      R1,??DataTable15_8
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    185              nrf_delay_us(MAX_RTC_TASKS_DELAY);
   \   00000030   0x202F             MOVS     R0,#+47
   \   00000032   0x.... 0x....      BL       nrf_delay_us
    186          
    187              m_rtc1_running = false;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x....             LDR      R1,??DataTable16
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
    188          }
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return
    189          
    190          
    191          /**@brief Function for returning the current value of the RTC1 counter.
    192           *
    193           * @return     Current value of the RTC1 counter.
    194           */

   \                                 In section .text, align 2, keep-with-next
    195          static __INLINE uint32_t rtc1_counter_get(void)
    196          {
    197              return NRF_RTC1->COUNTER;
   \                     rtc1_counter_get: (+1)
   \   00000000   0x....             LDR      R0,??DataTable16_1  ;; 0x40011504
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    198          }
    199          
    200          
    201          /**@brief Function for computing the difference between two RTC1 counter values.
    202           *
    203           * @return     Number of ticks elapsed from ticks_old to ticks_now.
    204           */

   \                                 In section .text, align 2, keep-with-next
    205          static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
    206          {
    207              return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
   \                     ticks_diff_get: (+1)
   \   00000000   0x1A40             SUBS     R0,R0,R1
   \   00000002   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000004   0x0A00             LSRS     R0,R0,#+8
   \   00000006   0x4770             BX       LR               ;; return
    208          }
    209          
    210          
    211          /**@brief Function for setting the RTC1 Capture Compare register 0, and enabling the corresponding
    212           *        event.
    213           *
    214           * @param[in] value   New value of Capture Compare register 0.
    215           */

   \                                 In section .text, align 2, keep-with-next
    216          static __INLINE void rtc1_compare0_set(uint32_t value)
    217          {
    218              NRF_RTC1->CC[0] = value;
   \                     rtc1_compare0_set: (+1)
   \   00000000   0x....             LDR      R1,??DataTable16_2  ;; 0x40011540
   \   00000002   0x6008             STR      R0,[R1, #+0]
    219          }
   \   00000004   0x4770             BX       LR               ;; return
    220          
    221          
    222          /**@brief Function for inserting a timer in the timer list.
    223           *
    224           * @param[in]  timer_id   Id of timer to insert.
    225           */

   \                                 In section .text, align 2, keep-with-next
    226          static void timer_list_insert(app_timer_id_t timer_id)
    227          {
   \                     timer_list_insert: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    228              timer_node_t * p_timer = &mp_nodes[timer_id];
   \   00000002   0x....             LDR      R1,??DataTable16_3
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2224             MOVS     R2,#+36
   \   00000008   0x4342             MULS     R2,R0,R2
   \   0000000A   0x1889             ADDS     R1,R1,R2
    229          
    230              if (m_timer_id_head == TIMER_NULL)
   \   0000000C   0x....             LDR      R2,??DataTable16_4
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x43DB             MVNS     R3,R3            ;; #-1
   \   00000014   0x429A             CMP      R2,R3
   \   00000016   0xD102             BNE      ??timer_list_insert_0
    231              {
    232                  m_timer_id_head = timer_id;
   \   00000018   0x....             LDR      R1,??DataTable16_4
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   \   0000001C   0xE05B             B        ??timer_list_insert_1
    233              }
    234              else
    235              {
    236                  if (p_timer->ticks_to_expire <= mp_nodes[m_timer_id_head].ticks_to_expire)
   \                     ??timer_list_insert_0: (+1)
   \   0000001E   0x....             LDR      R2,??DataTable16_3
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0x....             LDR      R3,??DataTable16_4
   \   00000024   0x681B             LDR      R3,[R3, #+0]
   \   00000026   0x2424             MOVS     R4,#+36
   \   00000028   0x4363             MULS     R3,R4,R3
   \   0000002A   0x18D2             ADDS     R2,R2,R3
   \   0000002C   0x6852             LDR      R2,[R2, #+4]
   \   0000002E   0x684B             LDR      R3,[R1, #+4]
   \   00000030   0x429A             CMP      R2,R3
   \   00000032   0xD317             BCC      ??timer_list_insert_2
    237                  {
    238                      mp_nodes[m_timer_id_head].ticks_to_expire -= p_timer->ticks_to_expire;
   \   00000034   0x....             LDR      R2,??DataTable16_3
   \   00000036   0x6812             LDR      R2,[R2, #+0]
   \   00000038   0x....             LDR      R3,??DataTable16_4
   \   0000003A   0x681B             LDR      R3,[R3, #+0]
   \   0000003C   0x2424             MOVS     R4,#+36
   \   0000003E   0x4363             MULS     R3,R4,R3
   \   00000040   0x18D2             ADDS     R2,R2,R3
   \   00000042   0x6852             LDR      R2,[R2, #+4]
   \   00000044   0x684B             LDR      R3,[R1, #+4]
   \   00000046   0x1AD2             SUBS     R2,R2,R3
   \   00000048   0x....             LDR      R3,??DataTable16_3
   \   0000004A   0x681B             LDR      R3,[R3, #+0]
   \   0000004C   0x....             LDR      R4,??DataTable16_4
   \   0000004E   0x6824             LDR      R4,[R4, #+0]
   \   00000050   0x2524             MOVS     R5,#+36
   \   00000052   0x436C             MULS     R4,R5,R4
   \   00000054   0x191B             ADDS     R3,R3,R4
   \   00000056   0x605A             STR      R2,[R3, #+4]
    239          
    240                      p_timer->next   = m_timer_id_head;
   \   00000058   0x....             LDR      R2,??DataTable16_4
   \   0000005A   0x6812             LDR      R2,[R2, #+0]
   \   0000005C   0x620A             STR      R2,[R1, #+32]
    241                      m_timer_id_head = timer_id;
   \   0000005E   0x....             LDR      R1,??DataTable16_4
   \   00000060   0x6008             STR      R0,[R1, #+0]
   \   00000062   0xE038             B        ??timer_list_insert_1
    242                  }
    243                  else
    244                  {
    245                      app_timer_id_t previous;
    246                      app_timer_id_t current;
    247                      uint32_t       ticks_to_expire;
    248          
    249                      ticks_to_expire = p_timer->ticks_to_expire;
   \                     ??timer_list_insert_2: (+1)
   \   00000064   0x684A             LDR      R2,[R1, #+4]
    250                      previous        = m_timer_id_head;
   \   00000066   0x....             LDR      R3,??DataTable16_4
   \   00000068   0x681C             LDR      R4,[R3, #+0]
    251                      current         = m_timer_id_head;
   \   0000006A   0x....             LDR      R3,??DataTable16_4
   \   0000006C   0x681B             LDR      R3,[R3, #+0]
   \   0000006E   0xE00D             B        ??timer_list_insert_3
    252          
    253                      while ((current != TIMER_NULL) && (ticks_to_expire > mp_nodes[current].ticks_to_expire))
    254                      {
    255                          ticks_to_expire -= mp_nodes[current].ticks_to_expire;
   \                     ??timer_list_insert_4: (+1)
   \   00000070   0x....             LDR      R4,??DataTable16_3
   \   00000072   0x6824             LDR      R4,[R4, #+0]
   \   00000074   0x2524             MOVS     R5,#+36
   \   00000076   0x435D             MULS     R5,R3,R5
   \   00000078   0x1964             ADDS     R4,R4,R5
   \   0000007A   0x6864             LDR      R4,[R4, #+4]
   \   0000007C   0x1B12             SUBS     R2,R2,R4
    256                          previous         = current;
   \   0000007E   0x001C             MOVS     R4,R3
    257                          current          = mp_nodes[current].next;
   \   00000080   0x....             LDR      R5,??DataTable16_3
   \   00000082   0x682D             LDR      R5,[R5, #+0]
   \   00000084   0x2624             MOVS     R6,#+36
   \   00000086   0x4373             MULS     R3,R6,R3
   \   00000088   0x18EB             ADDS     R3,R5,R3
   \   0000008A   0x6A1B             LDR      R3,[R3, #+32]
    258                      }
   \                     ??timer_list_insert_3: (+1)
   \   0000008C   0x2500             MOVS     R5,#+0
   \   0000008E   0x43ED             MVNS     R5,R5            ;; #-1
   \   00000090   0x42AB             CMP      R3,R5
   \   00000092   0xD007             BEQ      ??timer_list_insert_5
   \   00000094   0x....             LDR      R5,??DataTable16_3
   \   00000096   0x682D             LDR      R5,[R5, #+0]
   \   00000098   0x2624             MOVS     R6,#+36
   \   0000009A   0x435E             MULS     R6,R3,R6
   \   0000009C   0x19AD             ADDS     R5,R5,R6
   \   0000009E   0x686D             LDR      R5,[R5, #+4]
   \   000000A0   0x4295             CMP      R5,R2
   \   000000A2   0xD3E5             BCC      ??timer_list_insert_4
    259          
    260                      if (current != TIMER_NULL)
   \                     ??timer_list_insert_5: (+1)
   \   000000A4   0x2500             MOVS     R5,#+0
   \   000000A6   0x43ED             MVNS     R5,R5            ;; #-1
   \   000000A8   0x42AB             CMP      R3,R5
   \   000000AA   0xD00C             BEQ      ??timer_list_insert_6
    261                      {
    262                          mp_nodes[current].ticks_to_expire -= ticks_to_expire;
   \   000000AC   0x....             LDR      R5,??DataTable16_3
   \   000000AE   0x682D             LDR      R5,[R5, #+0]
   \   000000B0   0x2624             MOVS     R6,#+36
   \   000000B2   0x435E             MULS     R6,R3,R6
   \   000000B4   0x19AD             ADDS     R5,R5,R6
   \   000000B6   0x686D             LDR      R5,[R5, #+4]
   \   000000B8   0x1AAD             SUBS     R5,R5,R2
   \   000000BA   0x....             LDR      R6,??DataTable16_3
   \   000000BC   0x6836             LDR      R6,[R6, #+0]
   \   000000BE   0x2724             MOVS     R7,#+36
   \   000000C0   0x435F             MULS     R7,R3,R7
   \   000000C2   0x19F6             ADDS     R6,R6,R7
   \   000000C4   0x6075             STR      R5,[R6, #+4]
    263                      }
    264          
    265                      p_timer->ticks_to_expire = ticks_to_expire;
   \                     ??timer_list_insert_6: (+1)
   \   000000C6   0x604A             STR      R2,[R1, #+4]
    266                      p_timer->next            = current;
   \   000000C8   0x620B             STR      R3,[R1, #+32]
    267                      mp_nodes[previous].next  = timer_id;
   \   000000CA   0x....             LDR      R1,??DataTable16_3
   \   000000CC   0x6809             LDR      R1,[R1, #+0]
   \   000000CE   0x2224             MOVS     R2,#+36
   \   000000D0   0x4354             MULS     R4,R2,R4
   \   000000D2   0x1909             ADDS     R1,R1,R4
   \   000000D4   0x6208             STR      R0,[R1, #+32]
    268                  }
    269              }
    270          }
   \                     ??timer_list_insert_1: (+1)
   \   000000D6   0xBDF0             POP      {R4-R7,PC}       ;; return
    271          
    272          
    273          /**@brief Function for removing a timer from the timer queue.
    274           *
    275           * @param[in]  timer_id   Id of timer to remove.
    276           */

   \                                 In section .text, align 2, keep-with-next
    277          static void timer_list_remove(app_timer_id_t timer_id)
    278          {
   \                     timer_list_remove: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    279              app_timer_id_t previous;
    280              app_timer_id_t current;
    281              uint32_t       timeout;
    282          
    283              // Find the timer's position in timer list.
    284              previous = m_timer_id_head;
   \   00000002   0x....             LDR      R1,??DataTable16_4
   \   00000004   0x6809             LDR      R1,[R1, #+0]
    285              current  = previous;
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0xE006             B        ??timer_list_remove_0
    286          
    287              while (current != TIMER_NULL)
    288              {
    289                  if (current == timer_id)
    290                  {
    291                      break;
    292                  }
    293                  previous = current;
   \                     ??timer_list_remove_1: (+1)
   \   0000000A   0x0011             MOVS     R1,R2
    294                  current  = mp_nodes[current].next;
   \   0000000C   0x....             LDR      R3,??DataTable16_3
   \   0000000E   0x681B             LDR      R3,[R3, #+0]
   \   00000010   0x2424             MOVS     R4,#+36
   \   00000012   0x4362             MULS     R2,R4,R2
   \   00000014   0x189A             ADDS     R2,R3,R2
   \   00000016   0x6A12             LDR      R2,[R2, #+32]
   \                     ??timer_list_remove_0: (+1)
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x43DB             MVNS     R3,R3            ;; #-1
   \   0000001C   0x429A             CMP      R2,R3
   \   0000001E   0xD001             BEQ      ??timer_list_remove_2
   \   00000020   0x4282             CMP      R2,R0
   \   00000022   0xD1F2             BNE      ??timer_list_remove_1
    295              }
    296          
    297              // Timer not in active list.
    298              if (current == TIMER_NULL)
   \                     ??timer_list_remove_2: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000028   0x4282             CMP      R2,R0
   \   0000002A   0xD043             BEQ      ??timer_list_remove_3
    299              {
    300                  return;
    301              }
    302          
    303              // Timer is the first in the list
    304              if (previous == current)
   \                     ??timer_list_remove_4: (+1)
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD118             BNE      ??timer_list_remove_5
    305              {
    306                  m_timer_id_head = mp_nodes[m_timer_id_head].next;
   \   00000030   0x....             LDR      R0,??DataTable16_3
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x....             LDR      R3,??DataTable16_4
   \   00000036   0x681B             LDR      R3,[R3, #+0]
   \   00000038   0x2424             MOVS     R4,#+36
   \   0000003A   0x4363             MULS     R3,R4,R3
   \   0000003C   0x18C0             ADDS     R0,R0,R3
   \   0000003E   0x6A00             LDR      R0,[R0, #+32]
   \   00000040   0x....             LDR      R3,??DataTable16_4
   \   00000042   0x6018             STR      R0,[R3, #+0]
    307          
    308                  // No more timers in the list. Reset RTC1 in case Start timer operations are present in the queue.
    309                  if (m_timer_id_head == TIMER_NULL)
   \   00000044   0x....             LDR      R0,??DataTable16_4
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x2300             MOVS     R3,#+0
   \   0000004A   0x43DB             MVNS     R3,R3            ;; #-1
   \   0000004C   0x4298             CMP      R0,R3
   \   0000004E   0xD108             BNE      ??timer_list_remove_5
    310                  {
    311                      NRF_RTC1->TASKS_CLEAR = 1;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x....             LDR      R3,??DataTable15_7  ;; 0x40011008
   \   00000054   0x6018             STR      R0,[R3, #+0]
    312                      m_ticks_latest        = 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x....             LDR      R3,??DataTable15_8
   \   0000005A   0x6018             STR      R0,[R3, #+0]
    313                      m_rtc1_reset          = true;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x....             LDR      R3,??DataTable18
   \   00000060   0x7018             STRB     R0,[R3, #+0]
    314                  }
    315              }
    316          
    317              // Remaining timeout between next timeout.
    318              timeout = mp_nodes[current].ticks_to_expire;
   \                     ??timer_list_remove_5: (+1)
   \   00000062   0x....             LDR      R0,??DataTable16_3
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x2324             MOVS     R3,#+36
   \   00000068   0x4353             MULS     R3,R2,R3
   \   0000006A   0x18C0             ADDS     R0,R0,R3
   \   0000006C   0x6840             LDR      R0,[R0, #+4]
    319          
    320              // Link previous timer with next of this timer, i.e. removing the timer from list.
    321              mp_nodes[previous].next = mp_nodes[current].next;
   \   0000006E   0x....             LDR      R3,??DataTable16_3
   \   00000070   0x681B             LDR      R3,[R3, #+0]
   \   00000072   0x2424             MOVS     R4,#+36
   \   00000074   0x4362             MULS     R2,R4,R2
   \   00000076   0x189A             ADDS     R2,R3,R2
   \   00000078   0x6A12             LDR      R2,[R2, #+32]
   \   0000007A   0x....             LDR      R3,??DataTable16_3
   \   0000007C   0x681B             LDR      R3,[R3, #+0]
   \   0000007E   0x2424             MOVS     R4,#+36
   \   00000080   0x434C             MULS     R4,R1,R4
   \   00000082   0x191B             ADDS     R3,R3,R4
   \   00000084   0x621A             STR      R2,[R3, #+32]
    322          
    323              // If this is not the last timer, increment the next timer by this timer timeout.
    324              current = mp_nodes[previous].next;
   \   00000086   0x....             LDR      R2,??DataTable16_3
   \   00000088   0x6812             LDR      R2,[R2, #+0]
   \   0000008A   0x2324             MOVS     R3,#+36
   \   0000008C   0x4359             MULS     R1,R3,R1
   \   0000008E   0x1851             ADDS     R1,R2,R1
   \   00000090   0x6A0A             LDR      R2,[R1, #+32]
    325              if (current != TIMER_NULL)
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000096   0x428A             CMP      R2,R1
   \   00000098   0xD00C             BEQ      ??timer_list_remove_6
    326              {
    327                  mp_nodes[current].ticks_to_expire += timeout;
   \   0000009A   0x....             LDR      R1,??DataTable16_3
   \   0000009C   0x6809             LDR      R1,[R1, #+0]
   \   0000009E   0x2324             MOVS     R3,#+36
   \   000000A0   0x4353             MULS     R3,R2,R3
   \   000000A2   0x18C9             ADDS     R1,R1,R3
   \   000000A4   0x6849             LDR      R1,[R1, #+4]
   \   000000A6   0x1808             ADDS     R0,R1,R0
   \   000000A8   0x....             LDR      R1,??DataTable16_3
   \   000000AA   0x6809             LDR      R1,[R1, #+0]
   \   000000AC   0x2324             MOVS     R3,#+36
   \   000000AE   0x435A             MULS     R2,R3,R2
   \   000000B0   0x1889             ADDS     R1,R1,R2
   \   000000B2   0x6048             STR      R0,[R1, #+4]
    328              }
    329          }
   \                     ??timer_list_remove_6: (+1)
   \                     ??timer_list_remove_3: (+1)
   \   000000B4   0xBD10             POP      {R4,PC}          ;; return
    330          
    331          
    332          /**@brief Function for scheduling a check for timeouts by generating a RTC1 interrupt.
    333           */

   \                                 In section .text, align 2, keep-with-next
    334          static void timer_timeouts_check_sched(void)
    335          {
   \                     timer_timeouts_check_sched: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    336              NVIC_SetPendingIRQ(RTC1_IRQn);
   \   00000002   0x2011             MOVS     R0,#+17
   \   00000004   0x.... 0x....      BL       NVIC_SetPendingIRQ
    337          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    338          
    339          
    340          /**@brief Function for scheduling a timer list update by generating a SWI0 interrupt.
    341           */

   \                                 In section .text, align 2, keep-with-next
    342          static void timer_list_handler_sched(void)
    343          {
   \                     timer_list_handler_sched: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    344              NVIC_SetPendingIRQ(SWI0_IRQn);
   \   00000002   0x2014             MOVS     R0,#+20
   \   00000004   0x.... 0x....      BL       NVIC_SetPendingIRQ
    345          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    346          
    347          
    348          /**@brief Function for executing an application timeout handler, either by calling it directly, or
    349           *        by passing an event to the @ref app_scheduler.
    350           *
    351           * @param[in]  p_timer   Pointer to expired timer.
    352           */

   \                                 In section .text, align 2, keep-with-next
    353          static void timeout_handler_exec(timer_node_t * p_timer)
    354          {
   \                     timeout_handler_exec: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0002             MOVS     R2,R0
    355              if (m_evt_schedule_func != NULL)
   \   00000004   0x....             LDR      R0,??DataTable18_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00B             BEQ      ??timeout_handler_exec_0
    356              {
    357                  uint32_t err_code = m_evt_schedule_func(p_timer->p_timeout_handler, p_timer->p_context);
   \   0000000C   0x69D1             LDR      R1,[R2, #+28]
   \   0000000E   0x6990             LDR      R0,[R2, #+24]
   \   00000010   0x....             LDR      R2,??DataTable18_1
   \   00000012   0x6812             LDR      R2,[R2, #+0]
   \   00000014   0x4790             BLX      R2
    358                  APP_ERROR_CHECK(err_code);
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD003             BEQ      ??timeout_handler_exec_1
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x.... 0x....      BL       app_error_handler
   \                     ??timeout_handler_exec_1: (+1)
   \   00000022   0xE002             B        ??timeout_handler_exec_2
    359              }
    360              else
    361              {
    362                  p_timer->p_timeout_handler(p_timer->p_context);
   \                     ??timeout_handler_exec_0: (+1)
   \   00000024   0x69D0             LDR      R0,[R2, #+28]
   \   00000026   0x6991             LDR      R1,[R2, #+24]
   \   00000028   0x4788             BLX      R1
    363              }
    364          }
   \                     ??timeout_handler_exec_2: (+1)
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    365          
    366          
    367          /**@brief Function for checking for expired timers.
    368           */

   \                                 In section .text, align 2, keep-with-next
    369          static void timer_timeouts_check(void)
    370          {
   \                     timer_timeouts_check: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    371              // Handle expired of timer
    372              if (m_timer_id_head != TIMER_NULL)
   \   00000002   0x....             LDR      R0,??DataTable16_4
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD037             BEQ      ??timer_timeouts_check_0
    373              {
    374                  app_timer_id_t  timer_id;
    375                  uint32_t        ticks_elapsed;
    376                  uint32_t        ticks_expired;
    377          
    378                  // Initialize actual elapsed ticks being consumed to 0.
    379                  ticks_expired = 0;
   \   0000000E   0x2400             MOVS     R4,#+0
    380          
    381                  // ticks_elapsed is collected here, job will use it.
    382                  ticks_elapsed = ticks_diff_get(rtc1_counter_get(), m_ticks_latest);
   \   00000010   0x.... 0x....      BL       rtc1_counter_get
   \   00000014   0x....             LDR      R1,??DataTable15_8
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x.... 0x....      BL       ticks_diff_get
   \   0000001C   0x0005             MOVS     R5,R0
    383          
    384                  // Auto variable containing the head of timers expiring.
    385                  timer_id = m_timer_id_head;
   \   0000001E   0x....             LDR      R0,??DataTable16_4
   \   00000020   0x6806             LDR      R6,[R0, #+0]
   \   00000022   0xE006             B        ??timer_timeouts_check_1
    386          
    387                  // Expire all timers within ticks_elapsed and collect ticks_expired.
    388                  while (timer_id != TIMER_NULL)
    389                  {
    390                      timer_node_t * p_timer;
    391          
    392                      // Auto variable for current timer node
    393                      p_timer = &mp_nodes[timer_id];
    394          
    395                      // Do nothing if timer did not expire.
    396                      if (ticks_elapsed < p_timer->ticks_to_expire)
    397                      {
    398                          break;
    399                      }
    400          
    401                      // Decrement ticks_elapsed and collect expired ticks.
    402                      ticks_elapsed -= p_timer->ticks_to_expire;
   \                     ??timer_timeouts_check_2: (+1)
   \   00000024   0x6841             LDR      R1,[R0, #+4]
   \   00000026   0x1A6D             SUBS     R5,R5,R1
    403                      ticks_expired += p_timer->ticks_to_expire;
   \   00000028   0x6841             LDR      R1,[R0, #+4]
   \   0000002A   0x1864             ADDS     R4,R4,R1
    404          
    405                      // Move to next timer.
    406                      timer_id = p_timer->next;
   \   0000002C   0x6A06             LDR      R6,[R0, #+32]
    407          
    408                      // Execute Task.
    409                      timeout_handler_exec(p_timer);
   \   0000002E   0x.... 0x....      BL       timeout_handler_exec
   \                     ??timer_timeouts_check_1: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000036   0x4286             CMP      R6,R0
   \   00000038   0xD007             BEQ      ??timer_timeouts_check_3
   \   0000003A   0x....             LDR      R0,??DataTable16_3
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2124             MOVS     R1,#+36
   \   00000040   0x434E             MULS     R6,R1,R6
   \   00000042   0x1980             ADDS     R0,R0,R6
   \   00000044   0x6841             LDR      R1,[R0, #+4]
   \   00000046   0x428D             CMP      R5,R1
   \   00000048   0xD2EC             BCS      ??timer_timeouts_check_2
    410                  }
    411          
    412                  // Prepare to queue the ticks expired in the m_ticks_elapsed queue.
    413                  if (m_ticks_elapsed_q_read_ind == m_ticks_elapsed_q_write_ind)
   \                     ??timer_timeouts_check_3: (+1)
   \   0000004A   0x....             LDR      R0,??DataTable19
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x....             LDR      R1,??DataTable19_1
   \   00000050   0x7809             LDRB     R1,[R1, #+0]
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD10B             BNE      ??timer_timeouts_check_4
    414                  {
    415                      // The read index of the queue is equal to the write index. This means the new
    416                      // value of ticks_expired should be stored at a new location in the m_ticks_elapsed
    417                      // queue (which is implemented as a double buffer).
    418          
    419                      // Check if there will be a queue overflow.
    420                      if (++m_ticks_elapsed_q_write_ind == CONTEXT_QUEUE_SIZE_MAX)
   \   00000056   0x....             LDR      R0,??DataTable19_1
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0x....             LDR      R1,??DataTable19_1
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
   \   00000060   0x....             LDR      R0,??DataTable19_1
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x2802             CMP      R0,#+2
   \   00000066   0xD102             BNE      ??timer_timeouts_check_4
    421                      {
    422                          // There will be a queue overflow. Hence the write index should point to the start
    423                          // of the queue.
    424                          m_ticks_elapsed_q_write_ind = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x....             LDR      R1,??DataTable19_1
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
    425                      }
    426                  }
    427          
    428                  // Queue the ticks expired.
    429                  m_ticks_elapsed[m_ticks_elapsed_q_write_ind] = ticks_expired;
   \                     ??timer_timeouts_check_4: (+1)
   \   0000006E   0x....             LDR      R0,??DataTable19_2
   \   00000070   0x....             LDR      R1,??DataTable19_1
   \   00000072   0x7809             LDRB     R1,[R1, #+0]
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0x4351             MULS     R1,R2,R1
   \   00000078   0x5044             STR      R4,[R0, R1]
    430          
    431                  timer_list_handler_sched();
   \   0000007A   0x.... 0x....      BL       timer_list_handler_sched
    432              }
    433          }
   \                     ??timer_timeouts_check_0: (+1)
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return
    434          
    435          
    436          /**@brief Function for acquiring the number of ticks elapsed.
    437           *
    438           * @param[out] p_ticks_elapsed   Number of ticks elapsed.
    439           *
    440           * @return     TRUE if elapsed ticks was read from queue, FALSE otherwise.
    441           */

   \                                 In section .text, align 2, keep-with-next
    442          static bool elapsed_ticks_acquire(uint32_t * p_ticks_elapsed)
    443          {
   \                     elapsed_ticks_acquire: (+1)
   \   00000000   0xB500             PUSH     {LR}
    444              // Pick the elapsed value from queue.
    445              if (m_ticks_elapsed_q_read_ind != m_ticks_elapsed_q_write_ind)
   \   00000002   0x....             LDR      R1,??DataTable19
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x....             LDR      R2,??DataTable19_1
   \   00000008   0x7812             LDRB     R2,[R2, #+0]
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xD020             BEQ      ??elapsed_ticks_acquire_0
    446              {
    447                  // Dequeue elapsed value.
    448                  m_ticks_elapsed_q_read_ind++;
   \   0000000E   0x....             LDR      R1,??DataTable19
   \   00000010   0x7809             LDRB     R1,[R1, #+0]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x....             LDR      R2,??DataTable19
   \   00000016   0x7011             STRB     R1,[R2, #+0]
    449                  if (m_ticks_elapsed_q_read_ind == CONTEXT_QUEUE_SIZE_MAX)
   \   00000018   0x....             LDR      R1,??DataTable19
   \   0000001A   0x7809             LDRB     R1,[R1, #+0]
   \   0000001C   0x2902             CMP      R1,#+2
   \   0000001E   0xD102             BNE      ??elapsed_ticks_acquire_1
    450                  {
    451                      m_ticks_elapsed_q_read_ind = 0;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x....             LDR      R2,??DataTable19
   \   00000024   0x7011             STRB     R1,[R2, #+0]
    452                  }
    453          
    454                  *p_ticks_elapsed = m_ticks_elapsed[m_ticks_elapsed_q_read_ind];
   \                     ??elapsed_ticks_acquire_1: (+1)
   \   00000026   0x....             LDR      R1,??DataTable19_2
   \   00000028   0x....             LDR      R2,??DataTable19
   \   0000002A   0x7812             LDRB     R2,[R2, #+0]
   \   0000002C   0x2304             MOVS     R3,#+4
   \   0000002E   0x435A             MULS     R2,R3,R2
   \   00000030   0x5889             LDR      R1,[R1, R2]
   \   00000032   0x6001             STR      R1,[R0, #+0]
    455          
    456                  m_ticks_latest += *p_ticks_elapsed;
   \   00000034   0x....             LDR      R1,??DataTable20
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x1808             ADDS     R0,R1,R0
   \   0000003C   0x....             LDR      R1,??DataTable20
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    457                  m_ticks_latest &= MAX_RTC_COUNTER_VAL;
   \   00000040   0x....             LDR      R0,??DataTable20
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000046   0x0A00             LSRS     R0,R0,#+8
   \   00000048   0x....             LDR      R1,??DataTable20
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    458          
    459                  return true;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xE002             B        ??elapsed_ticks_acquire_2
    460              }
    461              else
    462              {
    463                  // No elapsed value in queue.
    464                  *p_ticks_elapsed = 0;
   \                     ??elapsed_ticks_acquire_0: (+1)
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x6001             STR      R1,[R0, #+0]
    465                  return false;
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??elapsed_ticks_acquire_2: (+1)
   \   00000056   0xBD00             POP      {PC}             ;; return
    466              }
    467          }
    468          
    469          
    470          /**@brief Function for handling the timer list deletions.
    471           *
    472           * @return     TRUE if Capture Compare register must be updated, FALSE otherwise.
    473           */

   \                                 In section .text, align 2, keep-with-next
    474          static bool list_deletions_handler(void)
    475          {
   \                     list_deletions_handler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    476              app_timer_id_t timer_id_old_head;
    477              uint8_t        user_id;
    478          
    479              // Remember the old head, so as to decide if new compare needs to be set.
    480              timer_id_old_head = m_timer_id_head;
   \   00000002   0x....             LDR      R0,??DataTable21
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x9000             STR      R0,[SP, #+0]
    481          
    482              user_id = m_user_array_size;
   \   00000008   0x....             LDR      R0,??DataTable20_1
   \   0000000A   0x7804             LDRB     R4,[R0, #+0]
    483              while (user_id--)
   \                     ??list_deletions_handler_0: (+1)
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x1E44             SUBS     R4,R0,#+1
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD03E             BEQ      ??list_deletions_handler_1
    484              {
    485                  timer_user_t * p_user         = &mp_users[user_id];
   \   00000016   0x....             LDR      R0,??DataTable21_1
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xB2E4             UXTB     R4,R4
   \   0000001C   0x2108             MOVS     R1,#+8
   \   0000001E   0x4361             MULS     R1,R4,R1
   \   00000020   0x1847             ADDS     R7,R0,R1
    486                  uint8_t        user_ops_first = p_user->first;
   \   00000022   0x783D             LDRB     R5,[R7, #+0]
   \   00000024   0xE011             B        ??list_deletions_handler_2
    487          
    488                  while (user_ops_first != p_user->last)
    489                  {
    490                      timer_node_t *    p_timer;
    491                      timer_user_op_t * p_user_op = &p_user->p_user_op_queue[user_ops_first];
    492          
    493                      // Traverse to next operation in queue.
    494                      user_ops_first++;
    495                      if (user_ops_first == p_user->user_op_queue_size)
    496                      {
    497                          user_ops_first = 0;
    498                      }
    499          
    500                      switch (p_user_op->op_type)
    501                      {
    502                          case TIMER_USER_OP_TYPE_STOP:
    503                              // Delete node if timer is running.
    504                              p_timer = &mp_nodes[p_user_op->timer_id];
    505                              if (p_timer->is_running)
    506                              {
    507                                  timer_list_remove(p_user_op->timer_id);
    508                                  p_timer->is_running = false;
    509                              }
    510                              break;
    511          
    512                          case TIMER_USER_OP_TYPE_STOP_ALL:
    513                              // Delete list of running timers, and mark all timers as not running.
    514                              while (m_timer_id_head != TIMER_NULL)
    515                              {
    516                                  timer_node_t * p_head = &mp_nodes[m_timer_id_head];
   \                     ??list_deletions_handler_3: (+1)
   \   00000026   0x....             LDR      R0,??DataTable18_2
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x....             LDR      R1,??DataTable21
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x2224             MOVS     R2,#+36
   \   00000030   0x4351             MULS     R1,R2,R1
   \   00000032   0x1840             ADDS     R0,R0,R1
    517          
    518                                  p_head->is_running = false;
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x7501             STRB     R1,[R0, #+20]
    519                                  m_timer_id_head    = p_head->next;
   \   00000038   0x6A00             LDR      R0,[R0, #+32]
   \   0000003A   0x....             LDR      R1,??DataTable21
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    520                              }
   \                     ??list_deletions_handler_4: (+1)
   \   0000003E   0x....             LDR      R0,??DataTable21
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD1ED             BNE      ??list_deletions_handler_3
    521                              break;
   \                     ??list_deletions_handler_2: (+1)
   \   0000004A   0x7878             LDRB     R0,[R7, #+1]
   \   0000004C   0xB2ED             UXTB     R5,R5
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xD0DC             BEQ      ??list_deletions_handler_0
   \   00000052   0x6878             LDR      R0,[R7, #+4]
   \   00000054   0xB2ED             UXTB     R5,R5
   \   00000056   0x2118             MOVS     R1,#+24
   \   00000058   0x4369             MULS     R1,R5,R1
   \   0000005A   0x1840             ADDS     R0,R0,R1
   \   0000005C   0x1C6D             ADDS     R5,R5,#+1
   \   0000005E   0x78B9             LDRB     R1,[R7, #+2]
   \   00000060   0xB2ED             UXTB     R5,R5
   \   00000062   0x428D             CMP      R5,R1
   \   00000064   0xD100             BNE      ??list_deletions_handler_5
   \   00000066   0x2500             MOVS     R5,#+0
   \                     ??list_deletions_handler_5: (+1)
   \   00000068   0x7801             LDRB     R1,[R0, #+0]
   \   0000006A   0x2902             CMP      R1,#+2
   \   0000006C   0xD002             BEQ      ??list_deletions_handler_6
   \   0000006E   0x2903             CMP      R1,#+3
   \   00000070   0xD0E5             BEQ      ??list_deletions_handler_4
   \   00000072   0xE00E             B        ??list_deletions_handler_7
   \                     ??list_deletions_handler_6: (+1)
   \   00000074   0x....             LDR      R1,??DataTable18_2
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0x6842             LDR      R2,[R0, #+4]
   \   0000007A   0x2324             MOVS     R3,#+36
   \   0000007C   0x435A             MULS     R2,R3,R2
   \   0000007E   0x188E             ADDS     R6,R1,R2
   \   00000080   0x7D31             LDRB     R1,[R6, #+20]
   \   00000082   0x2900             CMP      R1,#+0
   \   00000084   0xD004             BEQ      ??list_deletions_handler_8
   \   00000086   0x6840             LDR      R0,[R0, #+4]
   \   00000088   0x.... 0x....      BL       timer_list_remove
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x7530             STRB     R0,[R6, #+20]
   \                     ??list_deletions_handler_8: (+1)
   \   00000090   0xE7DB             B        ??list_deletions_handler_2
    522          
    523                          default:
    524                              // No implementation needed.
    525                              break;
   \                     ??list_deletions_handler_7: (+1)
   \   00000092   0xE7DA             B        ??list_deletions_handler_2
    526                      }
    527                  }
    528              }
    529          
    530              // Detect change in head of the list.
    531              return (m_timer_id_head != timer_id_old_head);
   \                     ??list_deletions_handler_1: (+1)
   \   00000094   0x....             LDR      R0,??DataTable21
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x9900             LDR      R1,[SP, #+0]
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xD001             BEQ      ??list_deletions_handler_9
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xE000             B        ??list_deletions_handler_10
   \                     ??list_deletions_handler_9: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \                     ??list_deletions_handler_10: (+1)
   \   000000A4   0xB2C0             UXTB     R0,R0
   \   000000A6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    532          }
    533          
    534          
    535          /**@brief Function for updating the timer list for expired timers.
    536           *
    537           * @param[in]  ticks_elapsed         Number of elapsed ticks.
    538           * @param[in]  ticks_previous        Previous known value of the RTC counter.
    539           * @param[out] p_restart_list_head   List of repeating timers to be restarted.
    540           */

   \                                 In section .text, align 2, keep-with-next
    541          static void expired_timers_handler(uint32_t         ticks_elapsed,
    542                                             uint32_t         ticks_previous,
    543                                             app_timer_id_t * p_restart_list_head)
    544          {
   \                     expired_timers_handler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    545              uint32_t ticks_expired = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE018             B        ??expired_timers_handler_0
    546          
    547              while (m_timer_id_head != TIMER_NULL)
    548              {
    549                  timer_node_t * p_timer;
    550                  app_timer_id_t id_expired;
    551          
    552                  // Auto variable for current timer node.
    553                  p_timer = &mp_nodes[m_timer_id_head];
    554          
    555                  // Do nothing if timer did not expire
    556                  if (ticks_elapsed < p_timer->ticks_to_expire)
    557                  {
    558                      p_timer->ticks_to_expire -= ticks_elapsed;
    559                      break;
    560                  }
    561          
    562                  // Decrement ticks_elapsed and collect expired ticks.
    563                  ticks_elapsed -= p_timer->ticks_to_expire;
   \                     ??expired_timers_handler_1: (+1)
   \   00000006   0x685D             LDR      R5,[R3, #+4]
   \   00000008   0x1B40             SUBS     R0,R0,R5
    564                  ticks_expired += p_timer->ticks_to_expire;
   \   0000000A   0x685D             LDR      R5,[R3, #+4]
   \   0000000C   0x1964             ADDS     R4,R4,R5
    565          
    566                  // Timer expired, set ticks_to_expire zero.
    567                  p_timer->ticks_to_expire = 0;
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0x605D             STR      R5,[R3, #+4]
    568                  p_timer->is_running      = false;
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0x751D             STRB     R5,[R3, #+20]
    569          
    570                  // Remove the expired timer from head.
    571                  id_expired      = m_timer_id_head;
   \   00000016   0x....             LDR      R5,??DataTable21
   \   00000018   0x682D             LDR      R5,[R5, #+0]
    572                  m_timer_id_head = p_timer->next;
   \   0000001A   0x6A1E             LDR      R6,[R3, #+32]
   \   0000001C   0x....             LDR      R7,??DataTable21
   \   0000001E   0x603E             STR      R6,[R7, #+0]
    573          
    574                  // Timer will be restarted if periodic.
    575                  if (p_timer->ticks_periodic_interval != 0)
   \   00000020   0x691E             LDR      R6,[R3, #+16]
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD008             BEQ      ??expired_timers_handler_0
    576                  {
    577                      p_timer->ticks_at_start       = (ticks_previous + ticks_expired) & MAX_RTC_COUNTER_VAL;
   \   00000026   0x190E             ADDS     R6,R1,R4
   \   00000028   0x0236             LSLS     R6,R6,#+8        ;; ZeroExtS R6,R6,#+8,#+8
   \   0000002A   0x0A36             LSRS     R6,R6,#+8
   \   0000002C   0x609E             STR      R6,[R3, #+8]
    578                      p_timer->ticks_first_interval = p_timer->ticks_periodic_interval;
   \   0000002E   0x691E             LDR      R6,[R3, #+16]
   \   00000030   0x60DE             STR      R6,[R3, #+12]
    579                      p_timer->next                 = *p_restart_list_head;
   \   00000032   0x6816             LDR      R6,[R2, #+0]
   \   00000034   0x621E             STR      R6,[R3, #+32]
    580                      *p_restart_list_head          = id_expired;
   \   00000036   0x6015             STR      R5,[R2, #+0]
    581                  }
   \                     ??expired_timers_handler_0: (+1)
   \   00000038   0x....             LDR      R3,??DataTable21
   \   0000003A   0x681B             LDR      R3,[R3, #+0]
   \   0000003C   0x2500             MOVS     R5,#+0
   \   0000003E   0x43ED             MVNS     R5,R5            ;; #-1
   \   00000040   0x42AB             CMP      R3,R5
   \   00000042   0xD00C             BEQ      ??expired_timers_handler_2
   \   00000044   0x....             LDR      R3,??DataTable18_2
   \   00000046   0x681B             LDR      R3,[R3, #+0]
   \   00000048   0x....             LDR      R5,??DataTable21
   \   0000004A   0x682D             LDR      R5,[R5, #+0]
   \   0000004C   0x2624             MOVS     R6,#+36
   \   0000004E   0x4375             MULS     R5,R6,R5
   \   00000050   0x195B             ADDS     R3,R3,R5
   \   00000052   0x685D             LDR      R5,[R3, #+4]
   \   00000054   0x42A8             CMP      R0,R5
   \   00000056   0xD2D6             BCS      ??expired_timers_handler_1
   \   00000058   0x6859             LDR      R1,[R3, #+4]
   \   0000005A   0x1A08             SUBS     R0,R1,R0
   \   0000005C   0x6058             STR      R0,[R3, #+4]
    582              }
    583          }
   \                     ??expired_timers_handler_2: (+1)
   \   0000005E   0xBDF0             POP      {R4-R7,PC}       ;; return
    584          
    585          
    586          /**@brief Function for handling timer list insertions.
    587           *
    588           * @param[in]  p_restart_list_head   List of repeating timers to be restarted.
    589           *
    590           * @return     TRUE if Capture Compare register must be updated, FALSE otherwise.
    591           */

   \                                 In section .text, align 2, keep-with-next
    592          static bool list_insertions_handler(app_timer_id_t restart_list_head)
    593          {
   \                     list_insertions_handler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
    594              app_timer_id_t timer_id_old_head;
    595              uint8_t        user_id;
    596          
    597              // Remember the old head, so as to decide if new compare needs to be set.
    598              timer_id_old_head = m_timer_id_head;
   \   00000006   0x....             LDR      R0,??DataTable21
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x9001             STR      R0,[SP, #+4]
    599          
    600              user_id = m_user_array_size;
   \   0000000C   0x....             LDR      R0,??DataTable20_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    601              while (user_id--)
   \                     ??list_insertions_handler_0: (+1)
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x1E42             SUBS     R2,R0,#+1
   \   0000001C   0x700A             STRB     R2,[R1, #+0]
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD070             BEQ      ??list_insertions_handler_1
    602              {
    603                  timer_user_t * p_user = &mp_users[user_id];
   \   00000024   0x....             LDR      R0,??DataTable21_1
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x7809             LDRB     R1,[R1, #+0]
   \   0000002C   0x2208             MOVS     R2,#+8
   \   0000002E   0x4351             MULS     R1,R2,R1
   \   00000030   0x1846             ADDS     R6,R0,R1
   \   00000032   0xE7FF             B        ??list_insertions_handler_2
    604          
    605                  // Handle insertions of timers.
    606                  while ((restart_list_head != TIMER_NULL) || (p_user->first != p_user->last))
    607                  {
    608                      app_timer_id_t id_start;
    609                      timer_node_t * p_timer;
    610          
    611                      if (restart_list_head != TIMER_NULL)
    612                      {
    613                          id_start          = restart_list_head;
    614                          p_timer           = &mp_nodes[id_start];
    615                          restart_list_head = p_timer->next;
    616                      }
    617                      else
    618                      {
    619                          timer_user_op_t * p_user_op = &p_user->p_user_op_queue[p_user->first];
    620          
    621                          p_user->first++;
    622                          if (p_user->first == p_user->user_op_queue_size)
    623                          {
    624                              p_user->first = 0;
    625                          }
    626          
    627                          id_start = p_user_op->timer_id;
    628                          p_timer  = &mp_nodes[id_start];
    629          
    630                          if ((p_user_op->op_type != TIMER_USER_OP_TYPE_START) || p_timer->is_running)
    631                          {
    632                              continue;
   \                     ??list_insertions_handler_3: (+1)
   \                     ??list_insertions_handler_2: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD103             BNE      ??list_insertions_handler_4
   \   0000003C   0x7830             LDRB     R0,[R6, #+0]
   \   0000003E   0x7871             LDRB     R1,[R6, #+1]
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD0E7             BEQ      ??list_insertions_handler_0
   \                     ??list_insertions_handler_4: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD007             BEQ      ??list_insertions_handler_5
   \   0000004C   0x0027             MOVS     R7,R4
   \   0000004E   0x....             LDR      R0,??DataTable25
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x2124             MOVS     R1,#+36
   \   00000054   0x4379             MULS     R1,R7,R1
   \   00000056   0x1845             ADDS     R5,R0,R1
   \   00000058   0x6A2C             LDR      R4,[R5, #+32]
   \   0000005A   0xE027             B        ??list_insertions_handler_6
   \                     ??list_insertions_handler_5: (+1)
   \   0000005C   0x6870             LDR      R0,[R6, #+4]
   \   0000005E   0x7831             LDRB     R1,[R6, #+0]
   \   00000060   0x2218             MOVS     R2,#+24
   \   00000062   0x4351             MULS     R1,R2,R1
   \   00000064   0x1840             ADDS     R0,R0,R1
   \   00000066   0x7831             LDRB     R1,[R6, #+0]
   \   00000068   0x1C49             ADDS     R1,R1,#+1
   \   0000006A   0x7031             STRB     R1,[R6, #+0]
   \   0000006C   0x7831             LDRB     R1,[R6, #+0]
   \   0000006E   0x78B2             LDRB     R2,[R6, #+2]
   \   00000070   0x4291             CMP      R1,R2
   \   00000072   0xD101             BNE      ??list_insertions_handler_7
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x7031             STRB     R1,[R6, #+0]
   \                     ??list_insertions_handler_7: (+1)
   \   00000078   0x6847             LDR      R7,[R0, #+4]
   \   0000007A   0x....             LDR      R1,??DataTable25
   \   0000007C   0x6809             LDR      R1,[R1, #+0]
   \   0000007E   0x2224             MOVS     R2,#+36
   \   00000080   0x437A             MULS     R2,R7,R2
   \   00000082   0x188D             ADDS     R5,R1,R2
   \   00000084   0x7801             LDRB     R1,[R0, #+0]
   \   00000086   0x2901             CMP      R1,#+1
   \   00000088   0xD1D4             BNE      ??list_insertions_handler_3
   \   0000008A   0x7D29             LDRB     R1,[R5, #+20]
   \   0000008C   0x2900             CMP      R1,#+0
   \   0000008E   0xD1D1             BNE      ??list_insertions_handler_3
    633                          }
    634          
    635                          p_timer->ticks_at_start          = p_user_op->params.start.ticks_at_start;
   \   00000090   0x6881             LDR      R1,[R0, #+8]
   \   00000092   0x60A9             STR      R1,[R5, #+8]
    636                          p_timer->ticks_first_interval    = p_user_op->params.start.ticks_first_interval;
   \   00000094   0x68C1             LDR      R1,[R0, #+12]
   \   00000096   0x60E9             STR      R1,[R5, #+12]
    637                          p_timer->ticks_periodic_interval = p_user_op->params.start.ticks_periodic_interval;
   \   00000098   0x6901             LDR      R1,[R0, #+16]
   \   0000009A   0x6129             STR      R1,[R5, #+16]
    638                          p_timer->p_context               = p_user_op->params.start.p_context;
   \   0000009C   0x6940             LDR      R0,[R0, #+20]
   \   0000009E   0x61E8             STR      R0,[R5, #+28]
    639          
    640                          if (m_rtc1_reset)
   \   000000A0   0x....             LDR      R0,??DataTable25_1
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD001             BEQ      ??list_insertions_handler_6
    641                          {
    642                              p_timer->ticks_at_start = 0;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x60A8             STR      R0,[R5, #+8]
    643                          }
    644                      }
    645          
    646                      // Prepare the node to be inserted.
    647                      if (
    648                           ((p_timer->ticks_at_start - m_ticks_latest) & MAX_RTC_COUNTER_VAL)
    649                           <
    650                           (MAX_RTC_COUNTER_VAL / 2)
    651                          )
   \                     ??list_insertions_handler_6: (+1)
   \   000000AC   0x68A8             LDR      R0,[R5, #+8]
   \   000000AE   0x....             LDR      R1,??DataTable20
   \   000000B0   0x6809             LDR      R1,[R1, #+0]
   \   000000B2   0x1A40             SUBS     R0,R0,R1
   \   000000B4   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   000000B6   0x0A00             LSRS     R0,R0,#+8
   \   000000B8   0x....             LDR      R1,??DataTable25_2  ;; 0x7fffff
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD208             BCS      ??list_insertions_handler_8
    652                      {
    653                          p_timer->ticks_to_expire = ticks_diff_get(p_timer->ticks_at_start, m_ticks_latest) +
    654                                                     p_timer->ticks_first_interval;
   \   000000BE   0x....             LDR      R0,??DataTable20
   \   000000C0   0x6801             LDR      R1,[R0, #+0]
   \   000000C2   0x68A8             LDR      R0,[R5, #+8]
   \   000000C4   0x.... 0x....      BL       ticks_diff_get
   \   000000C8   0x68E9             LDR      R1,[R5, #+12]
   \   000000CA   0x1840             ADDS     R0,R0,R1
   \   000000CC   0x6068             STR      R0,[R5, #+4]
   \   000000CE   0xE00D             B        ??list_insertions_handler_9
    655                      }
    656                      else
    657                      {
    658                          uint32_t delta_current_start;
    659          
    660                          delta_current_start = ticks_diff_get(m_ticks_latest, p_timer->ticks_at_start);
   \                     ??list_insertions_handler_8: (+1)
   \   000000D0   0x68A9             LDR      R1,[R5, #+8]
   \   000000D2   0x....             LDR      R0,??DataTable20
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x.... 0x....      BL       ticks_diff_get
    661                          if (p_timer->ticks_first_interval > delta_current_start)
   \   000000DA   0x68E9             LDR      R1,[R5, #+12]
   \   000000DC   0x4288             CMP      R0,R1
   \   000000DE   0xD203             BCS      ??list_insertions_handler_10
    662                          {
    663                              p_timer->ticks_to_expire = p_timer->ticks_first_interval - delta_current_start;
   \   000000E0   0x68E9             LDR      R1,[R5, #+12]
   \   000000E2   0x1A08             SUBS     R0,R1,R0
   \   000000E4   0x6068             STR      R0,[R5, #+4]
   \   000000E6   0xE001             B        ??list_insertions_handler_9
    664                          }
    665                          else
    666                          {
    667                              p_timer->ticks_to_expire = 0;
   \                     ??list_insertions_handler_10: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x6068             STR      R0,[R5, #+4]
    668                          }
    669                      }
    670          
    671                      p_timer->ticks_at_start       = 0;
   \                     ??list_insertions_handler_9: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x60A8             STR      R0,[R5, #+8]
    672                      p_timer->ticks_first_interval = 0;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x60E8             STR      R0,[R5, #+12]
    673                      p_timer->is_running           = true;
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0x7528             STRB     R0,[R5, #+20]
    674                      p_timer->next                 = TIMER_NULL;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x43C0             MVNS     R0,R0            ;; #-1
   \   000000FC   0x6228             STR      R0,[R5, #+32]
    675          
    676                      // Insert into list
    677                      timer_list_insert(id_start);
   \   000000FE   0x0038             MOVS     R0,R7
   \   00000100   0x.... 0x....      BL       timer_list_insert
   \   00000104   0xE796             B        ??list_insertions_handler_2
    678                  }
    679              }
    680          
    681              return (m_timer_id_head != timer_id_old_head);
   \                     ??list_insertions_handler_1: (+1)
   \   00000106   0x....             LDR      R0,??DataTable21
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0x9901             LDR      R1,[SP, #+4]
   \   0000010C   0x4288             CMP      R0,R1
   \   0000010E   0xD001             BEQ      ??list_insertions_handler_11
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0xE000             B        ??list_insertions_handler_12
   \                     ??list_insertions_handler_11: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
   \                     ??list_insertions_handler_12: (+1)
   \   00000116   0xB2C0             UXTB     R0,R0
   \   00000118   0xBDFE             POP      {R1-R7,PC}       ;; return
    682          }
    683          
    684          
    685          /**@brief Function for updating the Capture Compare register.
    686           */

   \                                 In section .text, align 2, keep-with-next
    687          static void compare_reg_update(app_timer_id_t timer_id_head_old)
    688          {
   \                     compare_reg_update: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    689              // Setup the timeout for timers on the head of the list
    690              if (m_timer_id_head != TIMER_NULL)
   \   00000002   0x....             LDR      R0,??DataTable21
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD033             BEQ      ??compare_reg_update_0
    691              {
    692                  uint32_t ticks_to_expire = mp_nodes[m_timer_id_head].ticks_to_expire;
   \   0000000E   0x....             LDR      R0,??DataTable25
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x....             LDR      R1,??DataTable21
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x2224             MOVS     R2,#+36
   \   00000018   0x4351             MULS     R1,R2,R1
   \   0000001A   0x1840             ADDS     R0,R0,R1
   \   0000001C   0x6845             LDR      R5,[R0, #+4]
    693                  uint32_t pre_counter_val = rtc1_counter_get();
   \   0000001E   0x.... 0x....      BL       rtc1_counter_get
   \   00000022   0x0007             MOVS     R7,R0
    694                  uint32_t cc              = m_ticks_latest;
   \   00000024   0x....             LDR      R0,??DataTable20
   \   00000026   0x6804             LDR      R4,[R0, #+0]
    695                  uint32_t ticks_elapsed   = ticks_diff_get(pre_counter_val, cc) + RTC_COMPARE_OFFSET_MIN;
   \   00000028   0x0021             MOVS     R1,R4
   \   0000002A   0x0038             MOVS     R0,R7
   \   0000002C   0x.... 0x....      BL       ticks_diff_get
   \   00000030   0x0006             MOVS     R6,R0
   \   00000032   0x1CF6             ADDS     R6,R6,#+3
    696          
    697                  if (!m_rtc1_running)
   \   00000034   0x....             LDR      R0,??DataTable27
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD101             BNE      ??compare_reg_update_1
    698                  {
    699                      // No timers were already running, start RTC
    700                      rtc1_start();
   \   0000003C   0x.... 0x....      BL       rtc1_start
    701                  }
    702          
    703                  cc += (ticks_elapsed < ticks_to_expire) ? ticks_to_expire : ticks_elapsed;
   \                     ??compare_reg_update_1: (+1)
   \   00000040   0x42AE             CMP      R6,R5
   \   00000042   0xD300             BCC      ??compare_reg_update_2
   \                     ??compare_reg_update_3: (+1)
   \   00000044   0x0035             MOVS     R5,R6
   \                     ??compare_reg_update_2: (+1)
   \   00000046   0x1964             ADDS     R4,R4,R5
    704                  cc &= MAX_RTC_COUNTER_VAL;
   \   00000048   0x0224             LSLS     R4,R4,#+8        ;; ZeroExtS R4,R4,#+8,#+8
   \   0000004A   0x0A24             LSRS     R4,R4,#+8
    705          
    706                  rtc1_compare0_set(cc);
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       rtc1_compare0_set
    707          
    708                  uint32_t post_counter_val = rtc1_counter_get();
   \   00000052   0x.... 0x....      BL       rtc1_counter_get
   \   00000056   0x0005             MOVS     R5,R0
    709          
    710                  if (
    711                      (ticks_diff_get(post_counter_val, pre_counter_val) + RTC_COMPARE_OFFSET_MIN)
    712                      >
    713                      ticks_diff_get(cc, pre_counter_val)
    714                     )
   \   00000058   0x0039             MOVS     R1,R7
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       ticks_diff_get
   \   00000060   0x0004             MOVS     R4,R0
   \   00000062   0x0039             MOVS     R1,R7
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0x.... 0x....      BL       ticks_diff_get
   \   0000006A   0x1CC0             ADDS     R0,R0,#+3
   \   0000006C   0x4284             CMP      R4,R0
   \   0000006E   0xD204             BCS      ??compare_reg_update_4
    715                  {
    716                      // When this happens the COMPARE event may not be triggered by the RTC.
    717                      // The nRF51 Series User Specification states that if the COUNTER value is N
    718                      // (i.e post_counter_val = N), writing N or N+1 to a CC register may not trigger a
    719                      // COMPARE event. Hence the RTC interrupt is forcefully pended by calling the following
    720                      // function.
    721                      timer_timeouts_check_sched();
   \   00000070   0x.... 0x....      BL       timer_timeouts_check_sched
   \   00000074   0xE001             B        ??compare_reg_update_4
    722                  }
    723              }
    724              else
    725              {
    726                  // No timers are running, stop RTC
    727                  rtc1_stop();
   \                     ??compare_reg_update_0: (+1)
   \   00000076   0x.... 0x....      BL       rtc1_stop
    728              }
    729          }
   \                     ??compare_reg_update_4: (+1)
   \   0000007A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    730          
    731          
    732          /**@brief Function for handling changes to the timer list.
    733           */

   \                                 In section .text, align 2, keep-with-next
    734          static void timer_list_handler(void)
    735          {
   \                     timer_list_handler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    736              app_timer_id_t restart_list_head = TIMER_NULL;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000008   0x9000             STR      R0,[SP, #+0]
    737              uint32_t       ticks_elapsed;
    738              uint32_t       ticks_previous;
    739              bool           ticks_have_elapsed;
    740              bool           compare_update;
    741              app_timer_id_t timer_id_head_old;
    742          
    743              // Back up the previous known tick and previous list head
    744              ticks_previous    = m_ticks_latest;
   \   0000000A   0x....             LDR      R0,??DataTable25_3
   \   0000000C   0x6804             LDR      R4,[R0, #+0]
    745              timer_id_head_old = m_timer_id_head;
   \   0000000E   0x....             LDR      R0,??DataTable21
   \   00000010   0x6807             LDR      R7,[R0, #+0]
    746          
    747              // Get number of elapsed ticks
    748              ticks_have_elapsed = elapsed_ticks_acquire(&ticks_elapsed);
   \   00000012   0xA801             ADD      R0,SP,#+4
   \   00000014   0x.... 0x....      BL       elapsed_ticks_acquire
   \   00000018   0x0005             MOVS     R5,R0
    749          //printf("ticks %u ", ticks_have_elapsed);
    750          
    751              // Handle list deletions
    752              compare_update = list_deletions_handler();
   \   0000001A   0x.... 0x....      BL       list_deletions_handler
   \   0000001E   0x0006             MOVS     R6,R0
    753          
    754              // Handle expired timers
    755              if (ticks_have_elapsed)
   \   00000020   0xB2ED             UXTB     R5,R5
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD005             BEQ      ??timer_list_handler_0
    756              {
    757                  expired_timers_handler(ticks_elapsed, ticks_previous, &restart_list_head);
   \   00000026   0x466A             MOV      R2,SP
   \   00000028   0x0021             MOVS     R1,R4
   \   0000002A   0x9801             LDR      R0,[SP, #+4]
   \   0000002C   0x.... 0x....      BL       expired_timers_handler
    758                  compare_update = true;
   \   00000030   0x2601             MOVS     R6,#+1
    759              }
    760          
    761              // Handle list insertions
    762              if (list_insertions_handler(restart_list_head))
   \                     ??timer_list_handler_0: (+1)
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0x.... 0x....      BL       list_insertions_handler
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD000             BEQ      ??timer_list_handler_1
    763              {
    764                  compare_update = true;
   \   0000003C   0x2601             MOVS     R6,#+1
    765              }
    766          
    767              // Update compare register if necessary
    768              if (compare_update)
   \                     ??timer_list_handler_1: (+1)
   \   0000003E   0xB2F6             UXTB     R6,R6
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD002             BEQ      ??timer_list_handler_2
    769              {
    770                  compare_reg_update(timer_id_head_old);
   \   00000044   0x0038             MOVS     R0,R7
   \   00000046   0x.... 0x....      BL       compare_reg_update
    771              }
    772              m_rtc1_reset = false;
   \                     ??timer_list_handler_2: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x....             LDR      R1,??DataTable25_1
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
    773          }
   \   00000050   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    774          
    775          
    776          /**@brief Function for enqueueing a new operations queue entry.
    777           *
    778           * @param[in]  p_user     User that the entry is to be enqueued for.
    779           * @param[in]  last_index Index of the next last index to be enqueued.
    780           */

   \                                 In section .text, align 2, keep-with-next
    781          static void user_op_enque(timer_user_t * p_user, app_timer_id_t last_index)
    782          {
    783              p_user->last = last_index;
   \                     user_op_enque: (+1)
   \   00000000   0x7041             STRB     R1,[R0, #+1]
    784          }
   \   00000002   0x4770             BX       LR               ;; return
    785          
    786          
    787          /**@brief Function for allocating a new operations queue entry.
    788           *
    789           * @param[in]  p_user       User that the entry is to be allocated for.
    790           * @param[out] p_last_index Index of the next last index to be enqueued.
    791           *
    792           * @return     Pointer to allocated queue entry, or NULL if queue is full.
    793           */

   \                                 In section .text, align 2, keep-with-next
    794          static timer_user_op_t * user_op_alloc(timer_user_t * p_user, app_timer_id_t * p_last_index)
    795          {
   \                     user_op_alloc: (+1)
   \   00000000   0xB500             PUSH     {LR}
    796              app_timer_id_t    last;
    797              timer_user_op_t * p_user_op;
    798          
    799              last = p_user->last + 1;
   \   00000002   0x7842             LDRB     R2,[R0, #+1]
   \   00000004   0x1C52             ADDS     R2,R2,#+1
    800              if (last == p_user->user_op_queue_size)
   \   00000006   0x7883             LDRB     R3,[R0, #+2]
   \   00000008   0x429A             CMP      R2,R3
   \   0000000A   0xD100             BNE      ??user_op_alloc_0
    801              {
    802                  // Overflow case.
    803                  last = 0;
   \   0000000C   0x2200             MOVS     R2,#+0
    804              }
    805              if (last == p_user->first)
   \                     ??user_op_alloc_0: (+1)
   \   0000000E   0x7803             LDRB     R3,[R0, #+0]
   \   00000010   0x429A             CMP      R2,R3
   \   00000012   0xD101             BNE      ??user_op_alloc_1
    806              {
    807                  // Queue is full.
    808                  return NULL;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE005             B        ??user_op_alloc_2
    809              }
    810          
    811              *p_last_index = last;
   \                     ??user_op_alloc_1: (+1)
   \   00000018   0x600A             STR      R2,[R1, #+0]
    812              p_user_op     = &p_user->p_user_op_queue[p_user->last];
   \   0000001A   0x6841             LDR      R1,[R0, #+4]
   \   0000001C   0x7840             LDRB     R0,[R0, #+1]
   \   0000001E   0x2218             MOVS     R2,#+24
   \   00000020   0x4350             MULS     R0,R2,R0
   \   00000022   0x1808             ADDS     R0,R1,R0
    813          
    814              return p_user_op;
   \                     ??user_op_alloc_2: (+1)
   \   00000024   0xBD00             POP      {PC}             ;; return
    815          }
    816          
    817          
    818          /**@brief Function for scheduling a Timer Start operation.
    819           *
    820           * @param[in]  user_id           Id of user calling this function.
    821           * @param[in]  timer_id          Id of timer to start.
    822           * @param[in]  timeout_initial   Time (in ticks) to first timer expiry.
    823           * @param[in]  timeout_periodic  Time (in ticks) between periodic expiries.
    824           * @param[in]  p_context         General purpose pointer. Will be passed to the timeout handler when
    825           *                               the timer expires.
    826           * @return     NRF_SUCCESS on success, otherwise an error code.
    827           */

   \                                 In section .text, align 2, keep-with-next
    828          static uint32_t timer_start_op_schedule(timer_user_id_t user_id,
    829                                                  app_timer_id_t  timer_id,
    830                                                  uint32_t        timeout_initial,
    831                                                  uint32_t        timeout_periodic,
    832                                                  void *          p_context)
    833          {
   \                     timer_start_op_schedule: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x001F             MOVS     R7,R3
    834              app_timer_id_t last_index;
    835          
    836              timer_user_op_t * p_user_op = user_op_alloc(&mp_users[user_id], &last_index);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x....             LDR      R0,??DataTable29
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x2208             MOVS     R2,#+8
   \   00000012   0x4362             MULS     R2,R4,R2
   \   00000014   0x1880             ADDS     R0,R0,R2
   \   00000016   0x.... 0x....      BL       user_op_alloc
   \   0000001A   0x0006             MOVS     R6,R0
    837              if (p_user_op == NULL)
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD101             BNE      ??timer_start_op_schedule_0
    838              {
    839                  return NRF_ERROR_NO_MEM;
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0xE015             B        ??timer_start_op_schedule_1
    840              }
    841          
    842              p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
   \                     ??timer_start_op_schedule_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7030             STRB     R0,[R6, #+0]
    843              p_user_op->timer_id                             = timer_id;
   \   00000028   0x6075             STR      R5,[R6, #+4]
    844              p_user_op->params.start.ticks_at_start          = rtc1_counter_get();
   \   0000002A   0x.... 0x....      BL       rtc1_counter_get
   \   0000002E   0x60B0             STR      R0,[R6, #+8]
    845              p_user_op->params.start.ticks_first_interval    = timeout_initial;
   \   00000030   0x9802             LDR      R0,[SP, #+8]
   \   00000032   0x60F0             STR      R0,[R6, #+12]
    846              p_user_op->params.start.ticks_periodic_interval = timeout_periodic;
   \   00000034   0x6137             STR      R7,[R6, #+16]
    847              p_user_op->params.start.p_context               = p_context;
   \   00000036   0x9808             LDR      R0,[SP, #+32]
   \   00000038   0x6170             STR      R0,[R6, #+20]
    848          
    849              user_op_enque(&mp_users[user_id], last_index);
   \   0000003A   0x9900             LDR      R1,[SP, #+0]
   \   0000003C   0x....             LDR      R0,??DataTable29
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x2208             MOVS     R2,#+8
   \   00000042   0x4354             MULS     R4,R2,R4
   \   00000044   0x1900             ADDS     R0,R0,R4
   \   00000046   0x.... 0x....      BL       user_op_enque
    850          
    851              timer_list_handler_sched();
   \   0000004A   0x.... 0x....      BL       timer_list_handler_sched
    852          
    853              return NRF_SUCCESS;
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??timer_start_op_schedule_1: (+1)
   \   00000050   0xBDFE             POP      {R1-R7,PC}       ;; return
    854          }
    855          
    856          
    857          /**@brief Function for scheduling a Timer Stop operation.
    858           *
    859           * @param[in]  user_id    Id of user calling this function.
    860           * @param[in]  timer_id   Id of timer to stop.
    861           *
    862           * @return NRF_SUCCESS on successful scheduling a timer stop operation. NRF_ERROR_NO_MEM when there
    863           *         is no memory left to schedule the timer stop operation.
    864           */

   \                                 In section .text, align 2, keep-with-next
    865          static uint32_t timer_stop_op_schedule(timer_user_id_t user_id, app_timer_id_t timer_id)
    866          {
   \                     timer_stop_op_schedule: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    867              app_timer_id_t last_index;
    868          
    869              timer_user_op_t * p_user_op = user_op_alloc(&mp_users[user_id], &last_index);
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x....             LDR      R0,??DataTable30
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2208             MOVS     R2,#+8
   \   0000000E   0x4362             MULS     R2,R4,R2
   \   00000010   0x1880             ADDS     R0,R0,R2
   \   00000012   0x.... 0x....      BL       user_op_alloc
    870              if (p_user_op == NULL)
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE      ??timer_stop_op_schedule_0
    871              {
    872                  return NRF_ERROR_NO_MEM;
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0xE00D             B        ??timer_stop_op_schedule_1
    873              }
    874          
    875              p_user_op->op_type  = TIMER_USER_OP_TYPE_STOP;
   \                     ??timer_stop_op_schedule_0: (+1)
   \   0000001E   0x2102             MOVS     R1,#+2
   \   00000020   0x7001             STRB     R1,[R0, #+0]
    876              p_user_op->timer_id = timer_id;
   \   00000022   0x6045             STR      R5,[R0, #+4]
    877          
    878              user_op_enque(&mp_users[user_id], last_index);
   \   00000024   0x9900             LDR      R1,[SP, #+0]
   \   00000026   0x....             LDR      R0,??DataTable30
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x2208             MOVS     R2,#+8
   \   0000002C   0x4354             MULS     R4,R2,R4
   \   0000002E   0x1900             ADDS     R0,R0,R4
   \   00000030   0x.... 0x....      BL       user_op_enque
    879          
    880              timer_list_handler_sched();
   \   00000034   0x.... 0x....      BL       timer_list_handler_sched
    881          
    882              return NRF_SUCCESS;
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??timer_stop_op_schedule_1: (+1)
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    883          }
    884          
    885          
    886          /**@brief Function for scheduling a Timer Stop All operation.
    887           *
    888           * @param[in]  user_id    Id of user calling this function.
    889           */

   \                                 In section .text, align 2, keep-with-next
    890          static uint32_t timer_stop_all_op_schedule(timer_user_id_t user_id)
    891          {
   \                     timer_stop_all_op_schedule: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    892              app_timer_id_t last_index;
    893          
    894              timer_user_op_t * p_user_op = user_op_alloc(&mp_users[user_id], &last_index);
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x....             LDR      R0,??DataTable30
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2208             MOVS     R2,#+8
   \   0000000E   0x4362             MULS     R2,R4,R2
   \   00000010   0x1880             ADDS     R0,R0,R2
   \   00000012   0x.... 0x....      BL       user_op_alloc
    895              if (p_user_op == NULL)
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE      ??timer_stop_all_op_schedule_0
    896              {
    897                  return NRF_ERROR_NO_MEM;
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0xE00F             B        ??timer_stop_all_op_schedule_1
    898              }
    899          
    900              p_user_op->op_type  = TIMER_USER_OP_TYPE_STOP_ALL;
   \                     ??timer_stop_all_op_schedule_0: (+1)
   \   0000001E   0x2103             MOVS     R1,#+3
   \   00000020   0x7001             STRB     R1,[R0, #+0]
    901              p_user_op->timer_id = TIMER_NULL;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000026   0x6041             STR      R1,[R0, #+4]
    902          
    903              user_op_enque(&mp_users[user_id], last_index);
   \   00000028   0x9900             LDR      R1,[SP, #+0]
   \   0000002A   0x....             LDR      R0,??DataTable30
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x2208             MOVS     R2,#+8
   \   00000030   0x4354             MULS     R4,R2,R4
   \   00000032   0x1900             ADDS     R0,R0,R4
   \   00000034   0x.... 0x....      BL       user_op_enque
    904          
    905              timer_list_handler_sched();
   \   00000038   0x.... 0x....      BL       timer_list_handler_sched
    906          
    907              return NRF_SUCCESS;
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??timer_stop_all_op_schedule_1: (+1)
   \   0000003E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    908          }
    909          
    910          
    911          /**@brief Function for handling the RTC1 interrupt.
    912           *
    913           * @details Checks for timeouts, and executes timeout handlers for expired timers.
    914           */

   \                                 In section .text, align 2, keep-with-next
    915          void RTC1_IRQHandler(void)
    916          {
   \                     RTC1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    917          //   printf("RTC1");
    918              // Clear all events (also unexpected ones)
    919              NRF_RTC1->EVENTS_COMPARE[0] = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR      R1,??DataTable30_1  ;; 0x40011140
   \   00000006   0x6008             STR      R0,[R1, #+0]
    920              NRF_RTC1->EVENTS_COMPARE[1] = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR      R1,??DataTable30_2  ;; 0x40011144
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    921              NRF_RTC1->EVENTS_COMPARE[2] = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR      R1,??DataTable30_3  ;; 0x40011148
   \   00000012   0x6008             STR      R0,[R1, #+0]
    922              NRF_RTC1->EVENTS_COMPARE[3] = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR      R1,??DataTable30_4  ;; 0x4001114c
   \   00000018   0x6008             STR      R0,[R1, #+0]
    923              NRF_RTC1->EVENTS_TICK       = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR      R1,??DataTable30_5  ;; 0x40011100
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    924              NRF_RTC1->EVENTS_OVRFLW     = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR      R1,??DataTable30_6  ;; 0x40011104
   \   00000024   0x6008             STR      R0,[R1, #+0]
    925          
    926              // Check for expired timers
    927              timer_timeouts_check();
   \   00000026   0x.... 0x....      BL       timer_timeouts_check
    928          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    929          
    930          
    931          /**@brief Function for handling the SWI0 interrupt.
    932           *
    933           * @details Performs all updates to the timer list.
    934           */

   \                                 In section .text, align 2, keep-with-next
    935          void SWI0_IRQHandler(void)
    936          {
   \                     SWI0_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    937              timer_list_handler();
   \   00000002   0x.... 0x....      BL       timer_list_handler
    938          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    939          
    940          

   \                                 In section .text, align 2, keep-with-next
    941          uint32_t app_timer_init(uint32_t                      prescaler,
    942                                  uint8_t                       max_timers,
    943                                  uint8_t                       op_queues_size,
    944                                  void *                        p_buffer,
    945                                  app_timer_evt_schedule_func_t evt_schedule_func)
    946          {
   \                     app_timer_init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x001E             MOVS     R6,R3
    947              int i;
    948          
    949              // Check that buffer is correctly aligned
    950              if (!is_word_aligned(p_buffer))
   \   0000000A   0x0030             MOVS     R0,R6
   \   0000000C   0x.... 0x....      BL       is_word_aligned
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE      ??app_timer_init_0
    951              {
    952                  return NRF_ERROR_INVALID_PARAM;
   \   00000014   0x2007             MOVS     R0,#+7
   \   00000016   0xE059             B        ??app_timer_init_1
    953              }
    954              // Check for NULL buffer
    955              if (p_buffer == NULL)
   \                     ??app_timer_init_0: (+1)
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD101             BNE      ??app_timer_init_2
    956              {
    957                  return NRF_ERROR_INVALID_PARAM;
   \   0000001C   0x2007             MOVS     R0,#+7
   \   0000001E   0xE055             B        ??app_timer_init_1
    958              }
    959          
    960              // Stop RTC to prevent any running timers from expiring (in case of reinitialization)
    961              rtc1_stop();
   \                     ??app_timer_init_2: (+1)
   \   00000020   0x.... 0x....      BL       rtc1_stop
    962          
    963              m_evt_schedule_func = evt_schedule_func;
   \   00000024   0x9806             LDR      R0,[SP, #+24]
   \   00000026   0x....             LDR      R1,??DataTable30_7
   \   00000028   0x6008             STR      R0,[R1, #+0]
    964          
    965              // Initialize timer node array
    966              m_node_array_size = max_timers;
   \   0000002A   0x....             LDR      R0,??DataTable30_8
   \   0000002C   0x7004             STRB     R4,[R0, #+0]
    967              mp_nodes          = p_buffer;
   \   0000002E   0x....             LDR      R0,??DataTable30_9
   \   00000030   0x6006             STR      R6,[R0, #+0]
    968          
    969              for (i = 0; i < max_timers; i++)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE00D             B        ??app_timer_init_3
    970              {
    971                  mp_nodes[i].state      = STATE_FREE;
   \                     ??app_timer_init_4: (+1)
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x....             LDR      R2,??DataTable30_9
   \   0000003A   0x6812             LDR      R2,[R2, #+0]
   \   0000003C   0x2324             MOVS     R3,#+36
   \   0000003E   0x4343             MULS     R3,R0,R3
   \   00000040   0x54D1             STRB     R1,[R2, R3]
    972                  mp_nodes[i].is_running = false;
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x....             LDR      R2,??DataTable30_9
   \   00000046   0x6812             LDR      R2,[R2, #+0]
   \   00000048   0x2324             MOVS     R3,#+36
   \   0000004A   0x4343             MULS     R3,R0,R3
   \   0000004C   0x18D2             ADDS     R2,R2,R3
   \   0000004E   0x7511             STRB     R1,[R2, #+20]
    973              }
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \                     ??app_timer_init_3: (+1)
   \   00000052   0xB2E4             UXTB     R4,R4
   \   00000054   0x42A0             CMP      R0,R4
   \   00000056   0xDBEE             BLT      ??app_timer_init_4
    974          
    975              // Skip timer node array
    976              p_buffer = &((uint8_t *)p_buffer)[max_timers * sizeof(timer_node_t)];
   \   00000058   0xB2E4             UXTB     R4,R4
   \   0000005A   0x2024             MOVS     R0,#+36
   \   0000005C   0x4344             MULS     R4,R0,R4
   \   0000005E   0x1936             ADDS     R6,R6,R4
    977          
    978              // Initialize users array
    979              m_user_array_size = APP_TIMER_INT_LEVELS;
   \   00000060   0x2003             MOVS     R0,#+3
   \   00000062   0x....             LDR      R1,??DataTable30_10
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    980              mp_users          = p_buffer;
   \   00000066   0x....             LDR      R0,??DataTable29
   \   00000068   0x6006             STR      R6,[R0, #+0]
    981          
    982              // Skip user array
    983              p_buffer = &((uint8_t *)p_buffer)[APP_TIMER_INT_LEVELS * sizeof(timer_user_t)];
   \   0000006A   0x3618             ADDS     R6,R6,#+24
    984          
    985              // Initialize operation queues
    986              for (i = 0; i < APP_TIMER_INT_LEVELS; i++)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE00F             B        ??app_timer_init_5
    987              {
    988                  timer_user_t * p_user = &mp_users[i];
   \                     ??app_timer_init_6: (+1)
   \   00000070   0x....             LDR      R1,??DataTable29
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0x2208             MOVS     R2,#+8
   \   00000076   0x4342             MULS     R2,R0,R2
   \   00000078   0x1889             ADDS     R1,R1,R2
    989          
    990                  p_user->first              = 0;
   \   0000007A   0x2200             MOVS     R2,#+0
   \   0000007C   0x700A             STRB     R2,[R1, #+0]
    991                  p_user->last               = 0;
   \   0000007E   0x2200             MOVS     R2,#+0
   \   00000080   0x704A             STRB     R2,[R1, #+1]
    992                  p_user->user_op_queue_size = op_queues_size;
   \   00000082   0x708F             STRB     R7,[R1, #+2]
    993                  p_user->p_user_op_queue    = p_buffer;
   \   00000084   0x604E             STR      R6,[R1, #+4]
    994          
    995                  // Skip operation queue
    996                  p_buffer = &((uint8_t *)p_buffer)[op_queues_size * sizeof(timer_user_op_t)];
   \   00000086   0xB2FF             UXTB     R7,R7
   \   00000088   0x2118             MOVS     R1,#+24
   \   0000008A   0x4379             MULS     R1,R7,R1
   \   0000008C   0x1876             ADDS     R6,R6,R1
    997              }
   \   0000008E   0x1C40             ADDS     R0,R0,#+1
   \                     ??app_timer_init_5: (+1)
   \   00000090   0x2803             CMP      R0,#+3
   \   00000092   0xDBED             BLT      ??app_timer_init_6
    998          
    999              m_timer_id_head             = TIMER_NULL;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000098   0x....             LDR      R1,??DataTable30_11
   \   0000009A   0x6008             STR      R0,[R1, #+0]
   1000              m_ticks_elapsed_q_read_ind  = 0;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x....             LDR      R1,??DataTable30_12
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
   1001              m_ticks_elapsed_q_write_ind = 0;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x....             LDR      R1,??DataTable30_13
   \   000000A6   0x7008             STRB     R0,[R1, #+0]
   1002          
   1003              NVIC_ClearPendingIRQ(SWI0_IRQn);
   \   000000A8   0x2014             MOVS     R0,#+20
   \   000000AA   0x.... 0x....      BL       NVIC_ClearPendingIRQ
   1004              NVIC_SetPriority(SWI0_IRQn, SWI0_IRQ_PRI);
   \   000000AE   0x2103             MOVS     R1,#+3
   \   000000B0   0x2014             MOVS     R0,#+20
   \   000000B2   0x.... 0x....      BL       NVIC_SetPriority
   1005              NVIC_EnableIRQ(SWI0_IRQn);
   \   000000B6   0x2014             MOVS     R0,#+20
   \   000000B8   0x.... 0x....      BL       NVIC_EnableIRQ
   1006          
   1007              rtc1_init(prescaler);
   \   000000BC   0x0028             MOVS     R0,R5
   \   000000BE   0x.... 0x....      BL       rtc1_init
   1008          
   1009              m_ticks_latest = rtc1_counter_get();
   \   000000C2   0x.... 0x....      BL       rtc1_counter_get
   \   000000C6   0x....             LDR      R1,??DataTable30_14
   \   000000C8   0x6008             STR      R0,[R1, #+0]
   1010          
   1011              return NRF_SUCCESS;
   \   000000CA   0x2000             MOVS     R0,#+0
   \                     ??app_timer_init_1: (+1)
   \   000000CC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1012          }
   1013          
   1014          

   \                                 In section .text, align 2, keep-with-next
   1015          uint32_t app_timer_create(app_timer_id_t *            p_timer_id,
   1016                                    app_timer_mode_t            mode,
   1017                                    app_timer_timeout_handler_t timeout_handler)
   1018          {
   \                     app_timer_create: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1019              int i;
   1020          
   1021              // Check state and parameters
   1022              if (mp_nodes == NULL)
   \   00000002   0x....             LDR      R3,??DataTable30_9
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0x2B00             CMP      R3,#+0
   \   00000008   0xD101             BNE      ??app_timer_create_0
   1023              {
   1024                  return NRF_ERROR_INVALID_STATE;
   \   0000000A   0x2008             MOVS     R0,#+8
   \   0000000C   0xE02C             B        ??app_timer_create_1
   1025              }
   1026              if (timeout_handler == NULL)
   \                     ??app_timer_create_0: (+1)
   \   0000000E   0x0013             MOVS     R3,R2
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD101             BNE      ??app_timer_create_2
   1027              {
   1028                  return NRF_ERROR_INVALID_PARAM;
   \   00000014   0x2007             MOVS     R0,#+7
   \   00000016   0xE027             B        ??app_timer_create_1
   1029              }
   1030              if (p_timer_id == NULL)
   \                     ??app_timer_create_2: (+1)
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE      ??app_timer_create_3
   1031              {
   1032                  return NRF_ERROR_INVALID_PARAM;
   \   0000001C   0x2007             MOVS     R0,#+7
   \   0000001E   0xE023             B        ??app_timer_create_1
   1033              }
   1034          
   1035              // Find free timer
   1036              for (i = 0; i < m_node_array_size; i++)
   \                     ??app_timer_create_3: (+1)
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0xE000             B        ??app_timer_create_4
   \                     ??app_timer_create_5: (+1)
   \   00000024   0x1C5B             ADDS     R3,R3,#+1
   \                     ??app_timer_create_4: (+1)
   \   00000026   0x....             LDR      R4,??DataTable30_8
   \   00000028   0x7824             LDRB     R4,[R4, #+0]
   \   0000002A   0x42A3             CMP      R3,R4
   \   0000002C   0xDA1B             BGE      ??app_timer_create_6
   1037              {
   1038                  if (mp_nodes[i].state == STATE_FREE)
   \   0000002E   0x....             LDR      R4,??DataTable30_9
   \   00000030   0x6824             LDR      R4,[R4, #+0]
   \   00000032   0x2524             MOVS     R5,#+36
   \   00000034   0x435D             MULS     R5,R3,R5
   \   00000036   0x5D64             LDRB     R4,[R4, R5]
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD1F3             BNE      ??app_timer_create_5
   1039                  {
   1040                      mp_nodes[i].state             = STATE_ALLOCATED;
   \   0000003C   0x2401             MOVS     R4,#+1
   \   0000003E   0x....             LDR      R5,??DataTable30_9
   \   00000040   0x682D             LDR      R5,[R5, #+0]
   \   00000042   0x2624             MOVS     R6,#+36
   \   00000044   0x435E             MULS     R6,R3,R6
   \   00000046   0x55AC             STRB     R4,[R5, R6]
   1041                      mp_nodes[i].mode              = mode;
   \   00000048   0x....             LDR      R4,??DataTable30_9
   \   0000004A   0x6824             LDR      R4,[R4, #+0]
   \   0000004C   0x2524             MOVS     R5,#+36
   \   0000004E   0x435D             MULS     R5,R3,R5
   \   00000050   0x1964             ADDS     R4,R4,R5
   \   00000052   0x7061             STRB     R1,[R4, #+1]
   1042                      mp_nodes[i].p_timeout_handler = timeout_handler;
   \   00000054   0x....             LDR      R1,??DataTable30_9
   \   00000056   0x6809             LDR      R1,[R1, #+0]
   \   00000058   0x2424             MOVS     R4,#+36
   \   0000005A   0x435C             MULS     R4,R3,R4
   \   0000005C   0x1909             ADDS     R1,R1,R4
   \   0000005E   0x618A             STR      R2,[R1, #+24]
   1043          
   1044                      *p_timer_id = i;
   \   00000060   0x6003             STR      R3,[R0, #+0]
   1045                      return NRF_SUCCESS;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE000             B        ??app_timer_create_1
   1046                  }
   1047              }
   1048          
   1049              return NRF_ERROR_NO_MEM;
   \                     ??app_timer_create_6: (+1)
   \   00000066   0x2004             MOVS     R0,#+4
   \                     ??app_timer_create_1: (+1)
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
   1050          }
   1051          
   1052          
   1053          /**@brief Function for creating a timer user id from the current interrupt level.
   1054           *
   1055           * @return     Timer user id.
   1056          */

   \                                 In section .text, align 2, keep-with-next
   1057          static timer_user_id_t user_id_get(void)
   1058          {
   \                     user_id_get: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1059              timer_user_id_t ret;
   1060          
   1061              STATIC_ASSERT(APP_TIMER_INT_LEVELS == 3);
   1062          
   1063              switch (current_int_priority_get())
   \   00000002   0x.... 0x....      BL       current_int_priority_get
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD002             BEQ      ??user_id_get_0
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD002             BEQ      ??user_id_get_1
   \   0000000E   0xE003             B        ??user_id_get_2
   1064              {
   1065                  case APP_IRQ_PRIORITY_HIGH:
   1066                      ret = APP_HIGH_USER_ID;
   \                     ??user_id_get_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   1067                      break;
   \   00000012   0xE002             B        ??user_id_get_3
   1068          
   1069                  case APP_IRQ_PRIORITY_LOW:
   1070                      ret = APP_LOW_USER_ID;
   \                     ??user_id_get_1: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   1071                      break;
   \   00000016   0xE000             B        ??user_id_get_3
   1072          
   1073                  default:
   1074                      ret = THREAD_MODE_USER_ID;
   \                     ??user_id_get_2: (+1)
   \   00000018   0x2002             MOVS     R0,#+2
   1075                      break;
   1076              }
   1077          
   1078              return ret;
   \                     ??user_id_get_3: (+1)
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
   1079          }
   1080          
   1081          

   \                                 In section .text, align 2, keep-with-next
   1082          uint32_t app_timer_start(app_timer_id_t timer_id, uint32_t timeout_ticks, void * p_context)
   1083          {
   \                     app_timer_start: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0017             MOVS     R7,R2
   1084              uint32_t timeout_periodic;
   1085          
   1086              // Check state and parameters
   1087              if (mp_nodes == NULL)
   \   00000008   0x....             LDR      R0,??DataTable30_9
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE      ??app_timer_start_0
   1088              {
   1089                  return NRF_ERROR_INVALID_STATE;
   \   00000010   0x2008             MOVS     R0,#+8
   \   00000012   0xE023             B        ??app_timer_start_1
   1090              }
   1091              if ((timer_id >= m_node_array_size) || (timeout_ticks < APP_TIMER_MIN_TIMEOUT_TICKS))
   \                     ??app_timer_start_0: (+1)
   \   00000014   0x....             LDR      R0,??DataTable30_8
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD201             BCS      ??app_timer_start_2
   \   0000001C   0x2D05             CMP      R5,#+5
   \   0000001E   0xD201             BCS      ??app_timer_start_3
   1092              {
   1093                  return NRF_ERROR_INVALID_PARAM;
   \                     ??app_timer_start_2: (+1)
   \   00000020   0x2007             MOVS     R0,#+7
   \   00000022   0xE01B             B        ??app_timer_start_1
   1094              }
   1095              if (mp_nodes[timer_id].state != STATE_ALLOCATED)
   \                     ??app_timer_start_3: (+1)
   \   00000024   0x....             LDR      R0,??DataTable30_9
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2124             MOVS     R1,#+36
   \   0000002A   0x4361             MULS     R1,R4,R1
   \   0000002C   0x5C40             LDRB     R0,[R0, R1]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD001             BEQ      ??app_timer_start_4
   1096              {
   1097                  return NRF_ERROR_INVALID_STATE;
   \   00000032   0x2008             MOVS     R0,#+8
   \   00000034   0xE012             B        ??app_timer_start_1
   1098              }
   1099          
   1100              // Schedule timer start operation
   1101              timeout_periodic = (mp_nodes[timer_id].mode == APP_TIMER_MODE_REPEATED) ? timeout_ticks : 0;
   \                     ??app_timer_start_4: (+1)
   \   00000036   0x....             LDR      R0,??DataTable30_9
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x2124             MOVS     R1,#+36
   \   0000003C   0x4361             MULS     R1,R4,R1
   \   0000003E   0x1840             ADDS     R0,R0,R1
   \   00000040   0x7840             LDRB     R0,[R0, #+1]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD101             BNE      ??app_timer_start_5
   \   00000046   0x002E             MOVS     R6,R5
   \   00000048   0xE000             B        ??app_timer_start_6
   \                     ??app_timer_start_5: (+1)
   \   0000004A   0x2600             MOVS     R6,#+0
   1102          
   1103              return timer_start_op_schedule(user_id_get(),
   1104                                             timer_id,
   1105                                             timeout_ticks,
   1106                                             timeout_periodic,
   1107                                             p_context);
   \                     ??app_timer_start_6: (+1)
   \   0000004C   0x.... 0x....      BL       user_id_get
   \   00000050   0x9700             STR      R7,[SP, #+0]
   \   00000052   0x0033             MOVS     R3,R6
   \   00000054   0x002A             MOVS     R2,R5
   \   00000056   0x0021             MOVS     R1,R4
   \   00000058   0x.... 0x....      BL       timer_start_op_schedule
   \                     ??app_timer_start_1: (+1)
   \   0000005C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1108          }
   1109          
   1110          

   \                                 In section .text, align 2, keep-with-next
   1111          uint32_t app_timer_stop(app_timer_id_t timer_id)
   1112          {
   \                     app_timer_stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1113              // Check state and parameters
   1114              if (mp_nodes == NULL)
   \   00000004   0x....             LDR      R0,??DataTable30_9
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE      ??app_timer_stop_0
   1115              {
   1116                  return NRF_ERROR_INVALID_STATE;
   \   0000000C   0x2008             MOVS     R0,#+8
   \   0000000E   0xE013             B        ??app_timer_stop_1
   1117              }
   1118              if (timer_id >= m_node_array_size)
   \                     ??app_timer_stop_0: (+1)
   \   00000010   0x....             LDR      R0,??DataTable30_8
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD301             BCC      ??app_timer_stop_2
   1119              {
   1120                  return NRF_ERROR_INVALID_PARAM;
   \   00000018   0x2007             MOVS     R0,#+7
   \   0000001A   0xE00D             B        ??app_timer_stop_1
   1121              }
   1122              if (mp_nodes[timer_id].state != STATE_ALLOCATED)
   \                     ??app_timer_stop_2: (+1)
   \   0000001C   0x....             LDR      R0,??DataTable30_9
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2124             MOVS     R1,#+36
   \   00000022   0x4361             MULS     R1,R4,R1
   \   00000024   0x5C40             LDRB     R0,[R0, R1]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD001             BEQ      ??app_timer_stop_3
   1123              {
   1124                  return NRF_ERROR_INVALID_STATE;
   \   0000002A   0x2008             MOVS     R0,#+8
   \   0000002C   0xE004             B        ??app_timer_stop_1
   1125              }
   1126          
   1127              // Schedule timer stop operation
   1128              return timer_stop_op_schedule(user_id_get(), timer_id);
   \                     ??app_timer_stop_3: (+1)
   \   0000002E   0x.... 0x....      BL       user_id_get
   \   00000032   0x0021             MOVS     R1,R4
   \   00000034   0x.... 0x....      BL       timer_stop_op_schedule
   \                     ??app_timer_stop_1: (+1)
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1129          }
   1130          
   1131          

   \                                 In section .text, align 2, keep-with-next
   1132          uint32_t app_timer_stop_all(void)
   1133          {
   \                     app_timer_stop_all: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1134              // Check state
   1135              if (mp_nodes == NULL)
   \   00000002   0x....             LDR      R0,??DataTable30_9
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE      ??app_timer_stop_all_0
   1136              {
   1137                  return NRF_ERROR_INVALID_STATE;
   \   0000000A   0x2008             MOVS     R0,#+8
   \   0000000C   0xE003             B        ??app_timer_stop_all_1
   1138              }
   1139          
   1140              return timer_stop_all_op_schedule(user_id_get());
   \                     ??app_timer_stop_all_0: (+1)
   \   0000000E   0x.... 0x....      BL       user_id_get
   \   00000012   0x.... 0x....      BL       timer_stop_all_op_schedule
   \                     ??app_timer_stop_all_1: (+1)
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
   1141          }
   1142          
   1143          

   \                                 In section .text, align 2, keep-with-next
   1144          uint32_t app_timer_cnt_get(uint32_t * p_ticks)
   1145          {
   \                     app_timer_cnt_get: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1146              *p_ticks = rtc1_counter_get();
   \   00000004   0x.... 0x....      BL       rtc1_counter_get
   \   00000008   0x6020             STR      R0,[R4, #+0]
   1147              return NRF_SUCCESS;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
   1148          }
   1149          
   1150          

   \                                 In section .text, align 2, keep-with-next
   1151          uint32_t app_timer_cnt_diff_compute(uint32_t   ticks_to,
   1152                                              uint32_t   ticks_from,
   1153                                              uint32_t * p_ticks_diff)
   1154          {
   \                     app_timer_cnt_diff_compute: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0014             MOVS     R4,R2
   1155              *p_ticks_diff = ticks_diff_get(ticks_to, ticks_from);
   \   00000004   0x.... 0x....      BL       ticks_diff_get
   \   00000008   0x6020             STR      R0,[R4, #+0]
   1156              return NRF_SUCCESS;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
   1157          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0xE000E200         DC32     0xe000e200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0xE000ED1C         DC32     0xe000ed1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40011344         DC32     0x40011344

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x40011508         DC32     0x40011508

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x40011304         DC32     0x40011304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x40011348         DC32     0x40011348

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x40011308         DC32     0x40011308

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x40011004         DC32     0x40011004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x40011008         DC32     0x40011008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x........         DC32     m_ticks_latest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     m_rtc1_running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40011504         DC32     0x40011504

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x40011540         DC32     0x40011540

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     mp_nodes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     m_timer_id_head

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     m_rtc1_reset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     m_evt_schedule_func

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     mp_nodes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     m_ticks_elapsed_q_read_ind

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     m_ticks_elapsed_q_write_ind

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     m_ticks_elapsed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     m_ticks_latest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     m_user_array_size

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     m_timer_id_head

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     mp_users

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     mp_nodes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x........         DC32     m_rtc1_reset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x007FFFFF         DC32     0x7fffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x........         DC32     m_ticks_latest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x........         DC32     m_rtc1_running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x........         DC32     mp_users

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x........         DC32     mp_users

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x40011140         DC32     0x40011140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0x40011144         DC32     0x40011144

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_3:
   \   00000000   0x40011148         DC32     0x40011148

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_4:
   \   00000000   0x4001114C         DC32     0x4001114c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_5:
   \   00000000   0x40011100         DC32     0x40011100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_6:
   \   00000000   0x40011104         DC32     0x40011104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_7:
   \   00000000   0x........         DC32     m_evt_schedule_func

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_8:
   \   00000000   0x........         DC32     m_node_array_size

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_9:
   \   00000000   0x........         DC32     mp_nodes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_10:
   \   00000000   0x........         DC32     m_user_array_size

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_11:
   \   00000000   0x........         DC32     m_timer_id_head

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_12:
   \   00000000   0x........         DC32     m_ticks_elapsed_q_read_ind

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_13:
   \   00000000   0x........         DC32     m_ticks_elapsed_q_write_ind

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_14:
   \   00000000   0x........         DC32     m_ticks_latest
   1158          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       4   NVIC_GetPriority
       0   NVIC_SetPendingIRQ
      20   NVIC_SetPriority
       8   RTC1_IRQHandler
         8   -> timer_timeouts_check
       8   SWI0_IRQHandler
         8   -> timer_list_handler
       8   app_timer_cnt_diff_compute
         8   -> ticks_diff_get
       8   app_timer_cnt_get
         8   -> rtc1_counter_get
      16   app_timer_create
      24   app_timer_init
        24   -> NVIC_ClearPendingIRQ
        24   -> NVIC_EnableIRQ
        24   -> NVIC_SetPriority
        24   -> is_word_aligned
        24   -> rtc1_counter_get
        24   -> rtc1_init
        24   -> rtc1_stop
      24   app_timer_start
        24   -> timer_start_op_schedule
        24   -> user_id_get
       8   app_timer_stop
         8   -> timer_stop_op_schedule
         8   -> user_id_get
       8   app_timer_stop_all
         8   -> timer_stop_all_op_schedule
         8   -> user_id_get
      24   compare_reg_update
        24   -> rtc1_compare0_set
        24   -> rtc1_counter_get
        24   -> rtc1_start
        24   -> rtc1_stop
        24   -> ticks_diff_get
        24   -> timer_timeouts_check_sched
       8   current_int_priority_get
         8   -> NVIC_GetPriority
       4   elapsed_ticks_acquire
      20   expired_timers_handler
       4   is_word_aligned
      24   list_deletions_handler
        24   -> timer_list_remove
      32   list_insertions_handler
        32   -> ticks_diff_get
        32   -> timer_list_insert
       0   nrf_delay_us
       0   rtc1_compare0_set
       0   rtc1_counter_get
       8   rtc1_init
         8   -> NVIC_SetPriority
       8   rtc1_start
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_EnableIRQ
         8   -> nrf_delay_us
       8   rtc1_stop
         8   -> NVIC_DisableIRQ
         8   -> nrf_delay_us
       0   ticks_diff_get
       8   timeout_handler_exec
         8   -- Indirect call
         8   -> app_error_handler
      32   timer_list_handler
        32   -> compare_reg_update
        32   -> elapsed_ticks_acquire
        32   -> expired_timers_handler
        32   -> list_deletions_handler
        32   -> list_insertions_handler
       8   timer_list_handler_sched
         8   -> NVIC_SetPendingIRQ
      20   timer_list_insert
       8   timer_list_remove
      32   timer_start_op_schedule
        32   -> rtc1_counter_get
        32   -> timer_list_handler_sched
        32   -> user_op_alloc
        32   -> user_op_enque
      16   timer_stop_all_op_schedule
        16   -> timer_list_handler_sched
        16   -> user_op_alloc
        16   -> user_op_enque
      16   timer_stop_op_schedule
        16   -> timer_list_handler_sched
        16   -> user_op_alloc
        16   -> user_op_enque
      16   timer_timeouts_check
        16   -> rtc1_counter_get
        16   -> ticks_diff_get
        16   -> timeout_handler_exec
        16   -> timer_list_handler_sched
       8   timer_timeouts_check_sched
         8   -> NVIC_SetPendingIRQ
       8   user_id_get
         8   -> current_int_priority_get
       4   user_op_alloc
       0   user_op_enque


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable27
       4  ??DataTable29
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_10
       4  ??DataTable30_11
       4  ??DataTable30_12
       4  ??DataTable30_13
       4  ??DataTable30_14
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
      14  NVIC_ClearPendingIRQ
      14  NVIC_DisableIRQ
      14  NVIC_EnableIRQ
      80  NVIC_GetPriority
      14  NVIC_SetPendingIRQ
     134  NVIC_SetPriority
      44  RTC1_IRQHandler
       8  SWI0_IRQHandler
      14  app_timer_cnt_diff_compute
      14  app_timer_cnt_get
     106  app_timer_create
     206  app_timer_init
      94  app_timer_start
      58  app_timer_stop
      24  app_timer_stop_all
     124  compare_reg_update
      30  current_int_priority_get
      88  elapsed_ticks_acquire
      96  expired_timers_handler
      16  is_word_aligned
     168  list_deletions_handler
     282  list_insertions_handler
       4  m_evt_schedule_func
       1  m_node_array_size
       1  m_rtc1_reset
       1  m_rtc1_running
       8  m_ticks_elapsed
       1  m_ticks_elapsed_q_read_ind
       1  m_ticks_elapsed_q_write_ind
       4  m_ticks_latest
       4  m_timer_id_head
       1  m_user_array_size
       4  mp_nodes
       4  mp_users
      30  nrf_delay_us
       6  rtc1_compare0_set
       6  rtc1_counter_get
      16  rtc1_init
      50  rtc1_start
      62  rtc1_stop
       8  ticks_diff_get
      44  timeout_handler_exec
      82  timer_list_handler
      10  timer_list_handler_sched
     216  timer_list_insert
     182  timer_list_remove
      82  timer_start_op_schedule
      64  timer_stop_all_op_schedule
      60  timer_stop_op_schedule
     128  timer_timeouts_check
      10  timer_timeouts_check_sched
      28  user_id_get
      38  user_op_alloc
       4  user_op_enque

 
    34 bytes in section .bss
 2 976 bytes in section .text
 
 2 976 bytes of CODE memory
    34 bytes of DATA memory

Errors: none
Warnings: none
