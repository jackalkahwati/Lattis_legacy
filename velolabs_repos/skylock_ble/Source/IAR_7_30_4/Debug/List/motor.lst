###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        16/Apr/2015  21:19:50
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\VeloLabs\SkyLock Project\Source\motor.c
#    Command line =  
#        "C:\VeloLabs\SkyLock Project\Source\motor.c" -D NRF51 -D
#        BLE_STACK_SUPPORT_REQD -lCN "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\Debug\List\" -o "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\Debug\Obj\" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Normal.h" -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\include\" -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\include\ARMFiles\" -I
#        "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\drivers_nrf\hal\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\softdevice\s110\headers\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\toolchain\" -I
#        "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\softdevice\common\softdevice_handler\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\util\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\scheduler\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\timer\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\ble\common\" -Ol
#    List file    =  
#        C:\VeloLabs\SkyLock Project\Source\IAR_7_30_4\Debug\List\motor.lst
#    Object file  =  
#        C:\VeloLabs\SkyLock Project\Source\IAR_7_30_4\Debug\Obj\motor.o
#
###############################################################################

C:\VeloLabs\SkyLock Project\Source\motor.c
      1          /*
      2          ** Proprietary Rights Notice
      3          **
      4          ** This material contains the valuable properties and trade secrets of:
      5          **
      6          **    Velo Labs
      7          **    San Francisco, CA, USA
      8          **
      9          ** All rights reserved. No part of this work may be reproduced, distributed, or
     10          ** transmitted in any form or by any means, including photocopying, recording,
     11          ** or other electronic or mechanical methods, without the prior written permission
     12          ** of Velo Labs.
     13          **
     14          ** Copyright (c) 2015, Velo Labs
     15          ** Contains Confidential and Trade Secret Information
     16          */
     17          
     18          /*
     19          ** File Name:  motor.c
     20          **
     21          ** Purpose:    Routines to manage the motor circuit
     22          */
     23          
     24          #include "master.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000004   0x0EC0             LSRS     R0,R0,#+27
   \   00000006   0x4081             LSLS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable6  ;; 0xe000e100
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000004   0x0EC0             LSRS     R0,R0,#+27
   \   00000006   0x4081             LSLS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable6_1  ;; 0xe000e280
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD521             BPL      ??NVIC_SetPriority_0
   \   00000008   0x....             LDR      R3,??DataTable6_2  ;; 0xe000ed1c
   \   0000000A   0xB240             SXTB     R0,R0
   \   0000000C   0x0702             LSLS     R2,R0,#+28       ;; ZeroExtS R2,R0,#+28,#+28
   \   0000000E   0x0F12             LSRS     R2,R2,#+28
   \   00000010   0x3A08             SUBS     R2,R2,#+8
   \   00000012   0x0892             LSRS     R2,R2,#+2
   \   00000014   0x2404             MOVS     R4,#+4
   \   00000016   0x4362             MULS     R2,R4,R2
   \   00000018   0x....             LDR      R4,??DataTable6_2  ;; 0xe000ed1c
   \   0000001A   0xB240             SXTB     R0,R0
   \   0000001C   0x0705             LSLS     R5,R0,#+28       ;; ZeroExtS R5,R0,#+28,#+28
   \   0000001E   0x0F2D             LSRS     R5,R5,#+28
   \   00000020   0x3D08             SUBS     R5,R5,#+8
   \   00000022   0x08AD             LSRS     R5,R5,#+2
   \   00000024   0x2604             MOVS     R6,#+4
   \   00000026   0x4375             MULS     R5,R6,R5
   \   00000028   0x5964             LDR      R4,[R4, R5]
   \   0000002A   0x25FF             MOVS     R5,#+255
   \   0000002C   0x0786             LSLS     R6,R0,#+30       ;; ZeroExtS R6,R0,#+30,#+30
   \   0000002E   0x0FB6             LSRS     R6,R6,#+30
   \   00000030   0x2708             MOVS     R7,#+8
   \   00000032   0x437E             MULS     R6,R7,R6
   \   00000034   0x40B5             LSLS     R5,R5,R6
   \   00000036   0x43AC             BICS     R4,R4,R5
   \   00000038   0x0189             LSLS     R1,R1,#+6
   \   0000003A   0xB2C9             UXTB     R1,R1
   \   0000003C   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000003E   0x0F80             LSRS     R0,R0,#+30
   \   00000040   0x2508             MOVS     R5,#+8
   \   00000042   0x4368             MULS     R0,R5,R0
   \   00000044   0x4081             LSLS     R1,R1,R0
   \   00000046   0x4321             ORRS     R1,R1,R4
   \   00000048   0x5099             STR      R1,[R3, R2]
   \   0000004A   0xE01B             B        ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0: (+1)
   \   0000004C   0x....             LDR      R2,??DataTable7  ;; 0xe000e400
   \   0000004E   0xB240             SXTB     R0,R0
   \   00000050   0x0003             MOVS     R3,R0
   \   00000052   0x089B             LSRS     R3,R3,#+2
   \   00000054   0x2404             MOVS     R4,#+4
   \   00000056   0x4363             MULS     R3,R4,R3
   \   00000058   0x58D2             LDR      R2,[R2, R3]
   \   0000005A   0x23FF             MOVS     R3,#+255
   \   0000005C   0x0784             LSLS     R4,R0,#+30       ;; ZeroExtS R4,R0,#+30,#+30
   \   0000005E   0x0FA4             LSRS     R4,R4,#+30
   \   00000060   0x2508             MOVS     R5,#+8
   \   00000062   0x436C             MULS     R4,R5,R4
   \   00000064   0x40A3             LSLS     R3,R3,R4
   \   00000066   0x439A             BICS     R2,R2,R3
   \   00000068   0x0189             LSLS     R1,R1,#+6
   \   0000006A   0xB2C9             UXTB     R1,R1
   \   0000006C   0x0783             LSLS     R3,R0,#+30       ;; ZeroExtS R3,R0,#+30,#+30
   \   0000006E   0x0F9B             LSRS     R3,R3,#+30
   \   00000070   0x2408             MOVS     R4,#+8
   \   00000072   0x4363             MULS     R3,R4,R3
   \   00000074   0x4099             LSLS     R1,R1,R3
   \   00000076   0x4311             ORRS     R1,R1,R2
   \   00000078   0x....             LDR      R2,??DataTable7  ;; 0xe000e400
   \   0000007A   0xB240             SXTB     R0,R0
   \   0000007C   0x0880             LSRS     R0,R0,#+2
   \   0000007E   0x2304             MOVS     R3,#+4
   \   00000080   0x4358             MULS     R0,R3,R0
   \   00000082   0x5011             STR      R1,[R2, R0]
   \                     ??NVIC_SetPriority_1: (+1)
   \   00000084   0xBDF0             POP      {R4-R7,PC}       ;; return
     25          #include "stdio.h"
     26          #include "hardware.h"
     27          #include "i2c.h"
     28          #include "timers.h"
     29          #include "utils.h"
     30          

   \                                 In section .bss, align 4
     31          volatile uint32_t MOTOR_Enc01Events;
   \                     MOTOR_Enc01Events:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     32          volatile uint32_t MOTOR_Enc02Events;
   \                     MOTOR_Enc02Events:
   \   00000000                      DS8 4
     33          
     34          /*
     35          ** Motor setup function. There are only 2 registers so there shouldn't be that much to actually do.
     36          ** But it appears if you don't first read the motor that the first command to the motor then doesn't work.
     37          ** So read the registers once.
     38          **
     39          ** Although once we can power off the motor, we will probably need a motor power up and down function.
     40          **
     41          ** For now, setup will do the following:
     42          ** #1). Setup the 2 encoder bits to go be interrupts. This also may change because once we know direction
     43          **      we really only should need 1 bit.
     44          **
     45          ** #2). Read from the motor chip so it is ready to go.
     46          **
     47          ** #3). Setup the motor ADC pin
     48          */

   \                                 In section .text, align 2, keep-with-next
     49          void
     50          Motor_Setup (void)
     51          {
   \                     Motor_Setup: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     52             uint8_t buffer[2];
     53          
     54                /*
     55                ** Setup the 2 encoding bits for interrupts right now. Go ahead and setup the pins as
     56                ** inputs for now. The GPIOTE seems to indicate it doesn't matter what we set them to
     57                ** but in case we don't use that, have them setup as an input.
     58                */
     59             NRF_GPIO->PIN_CNF[ENC_01] =
     60                      (GPIO_PIN_CNF_DIR_Input      << GPIO_PIN_CNF_DIR_Pos)
     61                    | (GPIO_PIN_CNF_INPUT_Connect  << GPIO_PIN_CNF_INPUT_Pos)
     62                    | (GPIO_PIN_CNF_PULL_Disabled  << GPIO_PIN_CNF_PULL_Pos)
     63                    | (GPIO_PIN_CNF_DRIVE_S0D1     << GPIO_PIN_CNF_DRIVE_Pos)
     64                    | (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos);
   \   00000002   0x20C0             MOVS     R0,#+192
   \   00000004   0x00C0             LSLS     R0,R0,#+3        ;; #+1536
   \   00000006   0x....             LDR      R1,??DataTable6_3  ;; 0x50000740
   \   00000008   0x6008             STR      R0,[R1, #+0]
     65          
     66             NRF_GPIO->PIN_CNF[ENC_02] =
     67                      (GPIO_PIN_CNF_DIR_Input      << GPIO_PIN_CNF_DIR_Pos)
     68                    | (GPIO_PIN_CNF_INPUT_Connect  << GPIO_PIN_CNF_INPUT_Pos)
     69                    | (GPIO_PIN_CNF_PULL_Disabled  << GPIO_PIN_CNF_PULL_Pos)
     70                    | (GPIO_PIN_CNF_DRIVE_S0D1     << GPIO_PIN_CNF_DRIVE_Pos)
     71                    | (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos);
   \   0000000A   0x20C0             MOVS     R0,#+192
   \   0000000C   0x00C0             LSLS     R0,R0,#+3        ;; #+1536
   \   0000000E   0x....             LDR      R1,??DataTable6_4  ;; 0x5000073c
   \   00000010   0x6008             STR      R0,[R1, #+0]
     72          
     73                /* Set ENC GPIO pins to events, rising edge */
     74             NRF_GPIOTE->CONFIG[0] =
     75                      (GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos)
     76                    | (ENC_01 << GPIOTE_CONFIG_PSEL_Pos)
     77                    | (GPIOTE_CONFIG_POLARITY_LoToHi << GPIOTE_CONFIG_POLARITY_Pos);
   \   00000012   0x....             LDR      R0,??DataTable6_5  ;; 0x11001
   \   00000014   0x....             LDR      R1,??DataTable6_6  ;; 0x40006510
   \   00000016   0x6008             STR      R0,[R1, #+0]
     78          
     79             NRF_GPIOTE->CONFIG[1] =
     80                      (GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos)
     81                    | (ENC_02 << GPIOTE_CONFIG_PSEL_Pos)
     82                    | (GPIOTE_CONFIG_POLARITY_LoToHi << GPIOTE_CONFIG_POLARITY_Pos);
   \   00000018   0x....             LDR      R0,??DataTable6_7  ;; 0x10f01
   \   0000001A   0x....             LDR      R1,??DataTable6_8  ;; 0x40006514
   \   0000001C   0x6008             STR      R0,[R1, #+0]
     83          
     84             NRF_GPIOTE->INTENSET = GPIOTE_INTENSET_IN0_Msk | GPIOTE_INTENSET_IN1_Msk;
   \   0000001E   0x2003             MOVS     R0,#+3
   \   00000020   0x....             LDR      R1,??DataTable7_1  ;; 0x40006304
   \   00000022   0x6008             STR      R0,[R1, #+0]
     85          
     86             NVIC_ClearPendingIRQ (GPIOTE_IRQn);
   \   00000024   0x2006             MOVS     R0,#+6
   \   00000026   0x.... 0x....      BL       NVIC_ClearPendingIRQ
     87             NVIC_SetPriority(GPIOTE_IRQn, SKYLOCK_PRIORITY);
   \   0000002A   0x2103             MOVS     R1,#+3
   \   0000002C   0x2006             MOVS     R0,#+6
   \   0000002E   0x.... 0x....      BL       NVIC_SetPriority
     88             NVIC_EnableIRQ (GPIOTE_IRQn);
   \   00000032   0x2006             MOVS     R0,#+6
   \   00000034   0x.... 0x....      BL       NVIC_EnableIRQ
     89          
     90                /*
     91                ** Make sure motor is clear. I saw case where after reboot, register 0 was FF and status register was 04. Actually
     92                ** turned off power supply to reboot and condition was still there. Writing 0 to the control register cleared the
     93                ** condition. So, it would seem a smart thing to do would be to do that as part of initialization.
     94                */
     95             buffer[0] = MOTOR_CTRL_REG;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
     96             buffer[1] = MOTOR_STANDBY;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x7048             STRB     R0,[R1, #+1]
     97             I2C_Write (I2C_ADDR_MOTOR, buffer, 2, TRUE);
   \   00000044   0x2301             MOVS     R3,#+1
   \   00000046   0x2202             MOVS     R2,#+2
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x2060             MOVS     R0,#+96
   \   0000004C   0x.... 0x....      BL       I2C_Write
     98          }
   \   00000050   0xBD01             POP      {R0,PC}          ;; return
     99          
    100          /*
    101          ** Kick the motor off in either the forward or backwards direction
    102          */

   \                                 In section .text, align 2, keep-with-next
    103          unsigned int
    104          Motor_Start (bool lock)
    105          {
   \                     Motor_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    106             uint8_t buffer[2];
    107             unsigned int status;
    108          
    109                /*
    110                ** Might as well just start these off at zero each time. That way anything testing can just reference them from
    111                ** 0 all of the time.
    112                */
    113             MOTOR_Enc01Events = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR      R1,??DataTable7_2
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    114             MOTOR_Enc02Events = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x....             LDR      R1,??DataTable8
   \   00000010   0x6008             STR      R0,[R1, #+0]
    115          
    116                /*
    117                ** Motor doesn't seem to respond until we read it. So always read it before we try to move it. Since we will
    118                ** be powering the motor down, probably want to do this everytime.
    119                */
    120             buffer[0] = MOTOR_CTRL_REG;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    121             status = I2C_Write (I2C_ADDR_MOTOR, buffer, 1, FALSE);
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x4669             MOV      R1,SP
   \   0000001E   0x2060             MOVS     R0,#+96
   \   00000020   0x.... 0x....      BL       I2C_Write
    122             if (status == 0)
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD116             BNE      ??Motor_Start_0
    123                {
    124                status = I2C_Read(I2C_ADDR_MOTOR, buffer, 2);
   \   00000028   0x2202             MOVS     R2,#+2
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x2060             MOVS     R0,#+96
   \   0000002E   0x.... 0x....      BL       I2C_Read
    125          
    126                if (status == 0)
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD10F             BNE      ??Motor_Start_0
    127                   {
    128                   if (lock)
   \   00000036   0xB2E4             UXTB     R4,R4
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD003             BEQ      ??Motor_Start_1
    129                      buffer[1] = MOTOR_REVERSE;
   \   0000003C   0x20FD             MOVS     R0,#+253
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x7048             STRB     R0,[R1, #+1]
   \   00000042   0xE002             B        ??Motor_Start_2
    130                   else
    131                      buffer[1] = MOTOR_FORWARD;
   \                     ??Motor_Start_1: (+1)
   \   00000044   0x20FE             MOVS     R0,#+254
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0x7048             STRB     R0,[R1, #+1]
    132          
    133                   status = I2C_Write (I2C_ADDR_MOTOR, buffer, 2, TRUE);
   \                     ??Motor_Start_2: (+1)
   \   0000004A   0x2301             MOVS     R3,#+1
   \   0000004C   0x2202             MOVS     R2,#+2
   \   0000004E   0x4669             MOV      R1,SP
   \   00000050   0x2060             MOVS     R0,#+96
   \   00000052   0x.... 0x....      BL       I2C_Write
    134                   }
    135                }
    136          
    137             return (status);
   \                     ??Motor_Start_0: (+1)
   \   00000056   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    138          }
    139          
    140          /*
    141          ** Stop the motor by first braking, then waiting for the motor to come to a stop and then putting the motor
    142          ** into standby mode.
    143          */

   \                                 In section .text, align 2, keep-with-next
    144          unsigned int
    145          Motor_Stop (void)
    146          {
   \                     Motor_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    147             uint8_t buffer[2];
    148             uint16_t latchTime;
    149             uint32_t latchEnc;
    150             unsigned int status;
    151          
    152             mfgBuffer[0] = MOTOR_STATUS_REG;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             LDR      R1,??DataTable7_3
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    153             I2C_FullRead (I2C_ADDR_MOTOR, mfgBuffer, 1);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x....             LDR      R1,??DataTable7_3
   \   0000000C   0x2060             MOVS     R0,#+96
   \   0000000E   0x.... 0x....      BL       I2C_FullRead
    154             if (mfgBuffer[1])
   \   00000012   0x....             LDR      R0,??DataTable7_3
   \   00000014   0x7840             LDRB     R0,[R0, #+1]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ      ??Motor_Stop_0
    155                printf("Motor error step 1 %u\n", mfgBuffer[1]);
   \   0000001A   0x....             LDR      R0,??DataTable7_3
   \   0000001C   0x7841             LDRB     R1,[R0, #+1]
   \   0000001E   0x....             LDR      R0,??DataTable8_1
   \   00000020   0x.... 0x....      BL       printf
    156          
    157                /*
    158                ** Use the brake option to stop the motor because it is much quicker. On a test where I was only going 10 counts, it looks
    159                ** like it took an extra 5 to stop. While the same test with going to standby first took an extra 20 or so steps.
    160                */
    161             buffer[0] = MOTOR_CTRL_REG;
   \                     ??Motor_Stop_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    162             buffer[1] = MOTOR_BRAKE;
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x7048             STRB     R0,[R1, #+1]
    163             status = I2C_Write (I2C_ADDR_MOTOR, buffer, 2, TRUE);
   \   00000030   0x2301             MOVS     R3,#+1
   \   00000032   0x2202             MOVS     R2,#+2
   \   00000034   0x4669             MOV      R1,SP
   \   00000036   0x2060             MOVS     R0,#+96
   \   00000038   0x.... 0x....      BL       I2C_Write
   \   0000003C   0x0004             MOVS     R4,R0
    164          
    165             if (status == 0)
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD14C             BNE      ??Motor_Stop_1
    166                {
    167                   /*
    168                   ** Wait for motor to actually stop. Watch both the encoder and a timer. We are looking for 20 milliseconds
    169                   ** after the last encoder reading. Then we will put the motor in standby mode.
    170                   */
    171                latchTime = Timer2_Count();
   \   00000042   0x.... 0x....      BL       Timer2_Count
   \   00000046   0x0004             MOVS     R4,R0
    172                latchEnc = MOTOR_Enc01Events;
   \   00000048   0x....             LDR      R0,??DataTable7_2
   \   0000004A   0x6805             LDR      R5,[R0, #+0]
   \   0000004C   0xE008             B        ??Motor_Stop_2
    173                while ((uint16_t)(Timer2_Count() - latchTime) < TIMER2_20_MSEC)
    174                   {
    175                   if (latchEnc != MOTOR_Enc01Events)
   \                     ??Motor_Stop_3: (+1)
   \   0000004E   0x....             LDR      R0,??DataTable7_2
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x4285             CMP      R5,R0
   \   00000054   0xD004             BEQ      ??Motor_Stop_2
    176                      {
    177                         /*
    178                         ** If the encoder moves, latch a new time value and start looking again.
    179                         */
    180                      latchTime = Timer2_Count();
   \   00000056   0x.... 0x....      BL       Timer2_Count
   \   0000005A   0x0004             MOVS     R4,R0
    181                      latchEnc = MOTOR_Enc01Events;
   \   0000005C   0x....             LDR      R0,??DataTable7_2
   \   0000005E   0x6805             LDR      R5,[R0, #+0]
    182                      }
    183                   }
   \                     ??Motor_Stop_2: (+1)
   \   00000060   0x.... 0x....      BL       Timer2_Count
   \   00000064   0x1B00             SUBS     R0,R0,R4
   \   00000066   0xB280             UXTH     R0,R0
   \   00000068   0x....             LDR      R1,??DataTable8_2  ;; 0x1388
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xDBEF             BLT      ??Motor_Stop_3
    184          
    185                if (mfgBuffer[1] == 0)
   \   0000006E   0x....             LDR      R0,??DataTable7_3
   \   00000070   0x7840             LDRB     R0,[R0, #+1]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD110             BNE      ??Motor_Stop_4
    186                   {
    187                   mfgBuffer[0] = MOTOR_STATUS_REG;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x....             LDR      R1,??DataTable7_3
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
    188                   I2C_FullRead (I2C_ADDR_MOTOR, mfgBuffer, 1);
   \   0000007C   0x2201             MOVS     R2,#+1
   \   0000007E   0x....             LDR      R1,??DataTable7_3
   \   00000080   0x2060             MOVS     R0,#+96
   \   00000082   0x.... 0x....      BL       I2C_FullRead
    189                   if (mfgBuffer[1])
   \   00000086   0x....             LDR      R0,??DataTable7_3
   \   00000088   0x7840             LDRB     R0,[R0, #+1]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD004             BEQ      ??Motor_Stop_4
    190                      printf("Motor error step 2 %u\n", mfgBuffer[1]);
   \   0000008E   0x....             LDR      R0,??DataTable7_3
   \   00000090   0x7841             LDRB     R1,[R0, #+1]
   \   00000092   0x....             LDR      R0,??DataTable8_3
   \   00000094   0x.... 0x....      BL       printf
    191                   }
    192          
    193                   /*
    194                   ** Motor does not seem to like the VSET ADC set to non-zero when turning the motor off. Had a test where I turned the motor
    195                   ** on, then turned it off and left VSET field enabled. I then tried the test again and the motor did not move. But if
    196                   ** I change the motor off function to write all 0's to the control register then there was no problem.
    197                   */
    198                buffer[0] = MOTOR_CTRL_REG;
   \                     ??Motor_Stop_4: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x4669             MOV      R1,SP
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
    199                buffer[1] = MOTOR_STANDBY;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x4669             MOV      R1,SP
   \   000000A2   0x7048             STRB     R0,[R1, #+1]
    200                status = I2C_Write (I2C_ADDR_MOTOR, buffer, 2, TRUE);
   \   000000A4   0x2301             MOVS     R3,#+1
   \   000000A6   0x2202             MOVS     R2,#+2
   \   000000A8   0x4669             MOV      R1,SP
   \   000000AA   0x2060             MOVS     R0,#+96
   \   000000AC   0x.... 0x....      BL       I2C_Write
   \   000000B0   0x0004             MOVS     R4,R0
    201          
    202                if (mfgBuffer[1] == 0)
   \   000000B2   0x....             LDR      R0,??DataTable7_3
   \   000000B4   0x7840             LDRB     R0,[R0, #+1]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD110             BNE      ??Motor_Stop_1
    203                   {
    204                   mfgBuffer[0] = MOTOR_STATUS_REG;
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0x....             LDR      R1,??DataTable7_3
   \   000000BE   0x7008             STRB     R0,[R1, #+0]
    205                   I2C_FullRead (I2C_ADDR_MOTOR, mfgBuffer, 1);
   \   000000C0   0x2201             MOVS     R2,#+1
   \   000000C2   0x....             LDR      R1,??DataTable7_3
   \   000000C4   0x2060             MOVS     R0,#+96
   \   000000C6   0x.... 0x....      BL       I2C_FullRead
    206                   if (mfgBuffer[1])
   \   000000CA   0x....             LDR      R0,??DataTable7_3
   \   000000CC   0x7840             LDRB     R0,[R0, #+1]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD004             BEQ      ??Motor_Stop_1
    207                      printf("Motor error step 2 %u\n", mfgBuffer[1]);
   \   000000D2   0x....             LDR      R0,??DataTable7_3
   \   000000D4   0x7841             LDRB     R1,[R0, #+1]
   \   000000D6   0x....             LDR      R0,??DataTable8_3
   \   000000D8   0x.... 0x....      BL       printf
    208                   }
    209                }
    210          
    211             return (status);
   \                     ??Motor_Stop_1: (+1)
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    212          }
    213          
    214          /*
    215          ** There isn't much to configure on ADC and since we will have more than 1 channel to read, might as well just hit everything each time a read
    216          ** is requested.
    217          **
    218          ** The data sheet lists 68 usec typical for a conversion. Using timer 2 set at 4usec units I am seeing about 19 ticks on average for this function
    219          ** to run. So basically just under 100 usec it looks like. Note the same specification mentions that a conversion pulls 260 uA during the
    220          ** conversion. Something to consider if we are looking for absolute power savings.
    221          */

   \                                 In section .text, align 2, keep-with-next
    222          uint16_t
    223          Motor_ADC (void)
    224          {
   \                     Motor_ADC: (+1)
   \   00000000   0xB500             PUSH     {LR}
    225             uint16_t result;
    226          
    227                /*
    228                ** Setup motor ADC pin
    229                */
    230             NRF_ADC->CONFIG =
    231                      ADC_CONFIG_RES_10bit
    232                    | (ADC_CONFIG_INPSEL_AnalogInputNoPrescaling << ADC_CONFIG_INPSEL_Pos)
    233                    | (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos)
    234                    | (ADC_CONFIG_PSEL_AnalogInput3 << ADC_CONFIG_PSEL_Pos)
    235                    | (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos);
   \   00000002   0x....             LDR      R0,??DataTable8_4  ;; 0x802
   \   00000004   0x....             LDR      R1,??DataTable8_5  ;; 0x40007504
   \   00000006   0x6008             STR      R0,[R1, #+0]
    236          
    237             NRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x....             LDR      R1,??DataTable8_6  ;; 0x40007500
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    238          
    239             NRF_ADC->TASKS_START = 1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x....             LDR      R1,??DataTable8_7  ;; 0x40007000
   \   00000012   0x6008             STR      R0,[R1, #+0]
    240          
    241             while (NRF_ADC->EVENTS_END == 0);
   \                     ??Motor_ADC_0: (+1)
   \   00000014   0x....             LDR      R0,??DataTable8_8  ;; 0x40007100
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD0FB             BEQ      ??Motor_ADC_0
    242          
    243             result = NRF_ADC->RESULT;
   \   0000001C   0x....             LDR      R0,??DataTable8_9  ;; 0x40007508
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
    244          
    245             NRF_ADC->EVENTS_END = 0;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x....             LDR      R2,??DataTable8_8  ;; 0x40007100
   \   00000024   0x6011             STR      R1,[R2, #+0]
    246             NRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Disabled;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x....             LDR      R2,??DataTable8_6  ;; 0x40007500
   \   0000002A   0x6011             STR      R1,[R2, #+0]
    247             NRF_ADC->TASKS_STOP = 1;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x....             LDR      R2,??DataTable8_10  ;; 0x40007004
   \   00000030   0x6011             STR      R1,[R2, #+0]
    248          
    249             return (result);
   \   00000032   0xB280             UXTH     R0,R0
   \   00000034   0xBD00             POP      {PC}             ;; return
    250          }
    251          
    252          /*
    253          ** Move the motor into either the locked position (lock is TRUE) or the unlock position (lock is FALSE)
    254          **
    255          ** Counts is the number of encoder pulses that should be measured. There are extra pulses that happen
    256          ** once the brake is thrown, but those are somewhat variable. This routine will attempt to account for
    257          ** those. Meaning if asked to move 120 pulses and we think it will take 5 to stop, we will move 115 and
    258          ** stop the motor. After the motor stops, if the total was indeed 120, we will return 120. If it is 121
    259          ** we will return 121 and the user knows we went 1 farther than they asked.
    260          **
    261          ** Basically this is the low level workhorse routine for moving the lock. A function must sit above this
    262          ** that then manages where the lock is (lock/unlock) and also how many counts it may be off so that the
    263          ** next time the lock moves, that adjustment will be factored in.
    264          **
    265          ** If the lock crashes into the stop, then we will back the lock up by 5 counts plus the brake amount. The
    266          ** total amount we moved will then be returned. Meaning if we move 120 and crash, then we will back up 5,
    267          ** plus the brake amount and maybe return something like 110.
    268          */
    269          #if 0
    270          /* this motor lock tries to use ADC and timing of encoder to stop */
    271          uint16_t
    272          Motor_Lock (bool lock, uint16_t encoderCounts)
    273          {
    274             bool     crash = FALSE;
    275             uint16_t t1, t2, lastTime[3], timeAve, timeMinAve;
    276             uint16_t lastAdc[3], adcAve, adcMinAve;
    277             uint32_t latch_enc;
    278             unsigned int status;
    279             unsigned int count;
    280          
    281          printf("Motor lock called with %u\n", lock);
    282             status = Motor_Start (lock);
    283             if (status)
    284                {
    285                printf("Write failed with %u\n", status);
    286                return (0);
    287                }
    288          
    289             t1 = Timer2_Count();
    290             latch_enc = 0;
    291             timeMinAve = adcMinAve = timeAve = adcAve = 10000;
    292             count = 10;
    293             while (MOTOR_Enc01Events < (encoderCounts - 5))
    294                {
    295                if (latch_enc != MOTOR_Enc01Events)
    296                   {
    297                   t2 = Timer2_Count();
    298                   latch_enc = MOTOR_Enc01Events;
    299          
    300                   lastTime[0] = lastTime[1];
    301                   lastTime[1] = lastTime[2];
    302                   lastTime[2] = (uint16_t)(t2 - t1);
    303                   lastAdc[0] = lastAdc[1];
    304                   lastAdc[1] = lastAdc[2];
    305                   lastAdc[2] = Motor_ADC();
    306          
    307                      /*
    308                      ** First couple of measurements could be bad and we are avoiding doing anything with them, so just
    309                      ** burn these.
    310                      */
    311                   if (latch_enc <= 4)
    312                      {
    313                      timeMinAve = lastTime[0] = lastTime[1] = timeAve = lastTime[2];
    314                      adcMinAve = lastAdc[0] = lastAdc[1] = adcAve = lastAdc[2];
    315                      }
    316          
    317                   timeAve = (lastTime[0] + lastTime[1] + lastTime[2]) / 3;
    318                   adcAve = (lastAdc[0] + lastAdc[1] + lastAdc[2]) / 3;
    319          
    320                   count--;
    321                   if (count)
    322                      {
    323                      if (timeAve < timeMinAve)
    324                         timeMinAve = timeAve;
    325          
    326                      if (adcAve < adcMinAve)
    327                         adcMinAve = adcAve;
    328                      }
    329                   else
    330                      {
    331                      count = 10;
    332                      timeMinAve = timeAve;
    333                      adcMinAve = adcAve;
    334                      }
    335          
    336                   if ((latch_enc < 20) || (latch_enc > 100))
    337                      printf("%03u: %03u/%03u %04u/%04u\n", latch_enc, lastAdc[2], adcAve, lastTime[2], timeAve);
    338                   t1 = t2;
    339                   }
    340          
    341                if ((MOTOR_Enc01Events > 12) && (timeAve > (timeMinAve + 10)) && (adcAve > (adcMinAve + 5)))
    342                   {
    343                   crash = TRUE;
    344                   break;
    345                   }
    346          
    347                if ((uint16_t)(Timer2_Count() - t1) > TIMER2_20_MSEC)
    348                   break;
    349                }
    350          
    351             status = Motor_Stop();
    352             printf("Enc #1: %u   Enc #2: %u  Status: %02x %02x\n", MOTOR_Enc01Events, MOTOR_Enc02Events, mfgBuffer[1], status);
    353             count = MOTOR_Enc01Events;
    354          
    355                /*
    356                ** Did we crash? If so, then backup some!
    357                */
    358             if (crash)
    359                {
    360                   /* Need to backup */
    361                status = Motor_Start (!lock);
    362                t1 = Timer2_Count();
    363                while (MOTOR_Enc01Events < 5)
    364                   {
    365                   if ((uint16_t)(Timer2_Count() - t1) > TIMER2_20_MSEC)
    366                      break;
    367                   }
    368          
    369                status = Motor_Stop ();
    370                count -= MOTOR_Enc01Events;
    371                }
    372             printf("Total steps requested and taken %u %u %u\n", encoderCounts, count, crash);
    373          
    374             return (count);
    375          }
    376          #else
    377          /* This version just uses fixed encoder counts to lock and unlock */

   \                                 In section .text, align 2, keep-with-next
    378          uint16_t
    379          Motor_Lock (bool lock, uint16_t encoderCounts)
    380          {
   \                     Motor_Lock: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
    381             uint16_t t1, t2, lastTime[3], timeAve, timeMinAve;
    382             uint32_t latch_enc;
    383             unsigned int status;
    384             unsigned int count;
    385          
    386          printf("Motor lock called with %u %u\n", lock, encoderCounts);
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x8A02             LDRH     R2,[R0, #+16]
   \   0000000A   0xB2E4             UXTB     R4,R4
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x....             LDR      R0,??DataTable8_11
   \   00000010   0x.... 0x....      BL       printf
    387             status = Motor_Start (lock);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0x.... 0x....      BL       Motor_Start
   \   0000001C   0x0001             MOVS     R1,R0
    388             if (status)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD004             BEQ      ??Motor_Lock_0
    389                {
    390                printf("Write failed with %u\n", status);
   \   00000022   0x....             LDR      R0,??DataTable8_12
   \   00000024   0x.... 0x....      BL       printf
    391                return (0);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE06C             B        ??Motor_Lock_1
    392                }
    393          
    394             t1 = Timer2_Count();
   \                     ??Motor_Lock_0: (+1)
   \   0000002C   0x.... 0x....      BL       Timer2_Count
   \   00000030   0x0006             MOVS     R6,R0
    395             latch_enc = 0;
   \   00000032   0x2500             MOVS     R5,#+0
    396             timeMinAve = timeAve = 10000;
   \   00000034   0x....             LDR      R0,??DataTable8_13  ;; 0x2710
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x8008             STRH     R0,[R1, #+0]
    397             count = 10;
   \   0000003A   0x240A             MOVS     R4,#+10
    398             while (MOTOR_Enc01Events < (encoderCounts - 5))
   \                     ??Motor_Lock_2: (+1)
   \   0000003C   0x....             LDR      R0,??DataTable7_2
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x8A09             LDRH     R1,[R1, #+16]
   \   00000044   0x1F49             SUBS     R1,R1,#+5
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD246             BCS      ??Motor_Lock_3
    399                {
    400                if (latch_enc != MOTOR_Enc01Events)
   \   0000004A   0x....             LDR      R0,??DataTable7_2
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xD03B             BEQ      ??Motor_Lock_4
    401                   {
    402                   t2 = Timer2_Count();
   \   00000052   0x.... 0x....      BL       Timer2_Count
   \   00000056   0x0007             MOVS     R7,R0
    403                   latch_enc = MOTOR_Enc01Events;
   \   00000058   0x....             LDR      R0,??DataTable7_2
   \   0000005A   0x6805             LDR      R5,[R0, #+0]
    404          
    405                   lastTime[0] = lastTime[1];
   \   0000005C   0x4668             MOV      R0,SP
   \   0000005E   0xA901             ADD      R1,SP,#+4
   \   00000060   0x8849             LDRH     R1,[R1, #+2]
   \   00000062   0x8081             STRH     R1,[R0, #+4]
    406                   lastTime[1] = lastTime[2];
   \   00000064   0xA801             ADD      R0,SP,#+4
   \   00000066   0x8880             LDRH     R0,[R0, #+4]
   \   00000068   0xA901             ADD      R1,SP,#+4
   \   0000006A   0x8048             STRH     R0,[R1, #+2]
    407                   lastTime[2] = (uint16_t)(t2 - t1);
   \   0000006C   0x1BB8             SUBS     R0,R7,R6
   \   0000006E   0xA901             ADD      R1,SP,#+4
   \   00000070   0x8088             STRH     R0,[R1, #+4]
    408          
    409                      /*
    410                      ** First couple of measurements could be bad and we are avoiding doing anything with them, so just
    411                      ** burn these.
    412                      */
    413                   if (latch_enc <= 4)
   \   00000072   0x2D05             CMP      R5,#+5
   \   00000074   0xD207             BCS      ??Motor_Lock_5
    414                      {
    415                      timeMinAve = lastTime[0] = lastTime[1] = timeAve = lastTime[2];
   \   00000076   0xA801             ADD      R0,SP,#+4
   \   00000078   0x8880             LDRH     R0,[R0, #+4]
   \   0000007A   0xA901             ADD      R1,SP,#+4
   \   0000007C   0x8048             STRH     R0,[R1, #+2]
   \   0000007E   0x4669             MOV      R1,SP
   \   00000080   0x8088             STRH     R0,[R1, #+4]
   \   00000082   0x4669             MOV      R1,SP
   \   00000084   0x8008             STRH     R0,[R1, #+0]
    416                      }
    417          
    418                   timeAve = (lastTime[0] + lastTime[1] + lastTime[2]) / 3;
   \                     ??Motor_Lock_5: (+1)
   \   00000086   0x4668             MOV      R0,SP
   \   00000088   0x8880             LDRH     R0,[R0, #+4]
   \   0000008A   0xA901             ADD      R1,SP,#+4
   \   0000008C   0x8849             LDRH     R1,[R1, #+2]
   \   0000008E   0x1840             ADDS     R0,R0,R1
   \   00000090   0xA901             ADD      R1,SP,#+4
   \   00000092   0x8889             LDRH     R1,[R1, #+4]
   \   00000094   0x1840             ADDS     R0,R0,R1
   \   00000096   0x2103             MOVS     R1,#+3
   \   00000098   0x.... 0x....      BL       __aeabi_idiv
    419          
    420                   count--;
   \   0000009C   0x1E64             SUBS     R4,R4,#+1
    421                   if (count)
   \   0000009E   0x2C00             CMP      R4,#+0
   \   000000A0   0xD007             BEQ      ??Motor_Lock_6
    422                      {
    423                      if (timeAve < timeMinAve)
   \   000000A2   0x4669             MOV      R1,SP
   \   000000A4   0x8809             LDRH     R1,[R1, #+0]
   \   000000A6   0xB280             UXTH     R0,R0
   \   000000A8   0x4288             CMP      R0,R1
   \   000000AA   0xD205             BCS      ??Motor_Lock_7
    424                         timeMinAve = timeAve;
   \   000000AC   0x4669             MOV      R1,SP
   \   000000AE   0x8008             STRH     R0,[R1, #+0]
   \   000000B0   0xE002             B        ??Motor_Lock_7
    425                      }
    426                   else
    427                      {
    428                      count = 10;
   \                     ??Motor_Lock_6: (+1)
   \   000000B2   0x240A             MOVS     R4,#+10
    429                      timeMinAve = timeAve;
   \   000000B4   0x4669             MOV      R1,SP
   \   000000B6   0x8008             STRH     R0,[R1, #+0]
    430                      }
    431          
    432                   printf("%03u: %04u/%04u\n", latch_enc, lastTime[2], timeAve);
   \                     ??Motor_Lock_7: (+1)
   \   000000B8   0xB280             UXTH     R0,R0
   \   000000BA   0x0003             MOVS     R3,R0
   \   000000BC   0xA801             ADD      R0,SP,#+4
   \   000000BE   0x8882             LDRH     R2,[R0, #+4]
   \   000000C0   0x0029             MOVS     R1,R5
   \   000000C2   0x....             LDR      R0,??DataTable8_14
   \   000000C4   0x.... 0x....      BL       printf
    433                   t1 = t2;
   \   000000C8   0x003E             MOVS     R6,R7
    434                   }
    435          
    436                   /* If encoder not moving, stop */
    437                if ((uint16_t)(Timer2_Count() - t1) > TIMER2_20_MSEC)
   \                     ??Motor_Lock_4: (+1)
   \   000000CA   0x.... 0x....      BL       Timer2_Count
   \   000000CE   0x1B80             SUBS     R0,R0,R6
   \   000000D0   0xB280             UXTH     R0,R0
   \   000000D2   0x....             LDR      R1,??DataTable8_15  ;; 0x1389
   \   000000D4   0x4288             CMP      R0,R1
   \   000000D6   0xDBB1             BLT      ??Motor_Lock_2
    438                   break;
    439                }
    440          
    441             status = Motor_Stop();
   \                     ??Motor_Lock_3: (+1)
   \   000000D8   0x.... 0x....      BL       Motor_Stop
   \   000000DC   0x0001             MOVS     R1,R0
    442             printf("Enc #1: %u   Enc #2: %u  Status: %02x %02x\n", MOTOR_Enc01Events, MOTOR_Enc02Events, mfgBuffer[1], status);
   \   000000DE   0x....             LDR      R0,??DataTable8
   \   000000E0   0x6802             LDR      R2,[R0, #+0]
   \   000000E2   0x9100             STR      R1,[SP, #+0]
   \   000000E4   0x....             LDR      R0,??DataTable7_3
   \   000000E6   0x7843             LDRB     R3,[R0, #+1]
   \   000000E8   0x....             LDR      R0,??DataTable7_2
   \   000000EA   0x6801             LDR      R1,[R0, #+0]
   \   000000EC   0x....             LDR      R0,??DataTable8_16
   \   000000EE   0x.... 0x....      BL       printf
    443             count = MOTOR_Enc01Events;
   \   000000F2   0x....             LDR      R0,??DataTable7_2
   \   000000F4   0x6804             LDR      R4,[R0, #+0]
    444          
    445             printf("Total steps requested and taken %u %u\n", encoderCounts, count);
   \   000000F6   0x0022             MOVS     R2,R4
   \   000000F8   0x4668             MOV      R0,SP
   \   000000FA   0x8A01             LDRH     R1,[R0, #+16]
   \   000000FC   0x....             LDR      R0,??DataTable8_17
   \   000000FE   0x.... 0x....      BL       printf
    446          
    447             return (count);
   \   00000102   0x0020             MOVS     R0,R4
   \   00000104   0xB280             UXTH     R0,R0
   \                     ??Motor_Lock_1: (+1)
   \   00000106   0xB005             ADD      SP,SP,#+20
   \   00000108   0xBDF0             POP      {R4-R7,PC}       ;; return
    448          }
    449          #endif
    450          
    451          
    452          /*
    453          ** There is only 1 interrupt handler for GPIO pins so if we get an event we need to search which device
    454          ** caused the event.
    455          */

   \                                 In section .text, align 2, keep-with-next
    456          void
    457          GPIOTE_Handler (void)
    458          {
   \                     GPIOTE_Handler: (+1)
   \   00000000   0xB500             PUSH     {LR}
    459                /* Checking Config #0 */
    460             if (NRF_GPIOTE->EVENTS_IN[0])
   \   00000002   0x....             LDR      R0,??DataTable8_18  ;; 0x40006100
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD008             BEQ      ??GPIOTE_Handler_0
    461                {
    462                MOTOR_Enc01Events++;
   \   0000000A   0x....             LDR      R0,??DataTable8_19
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x....             LDR      R1,??DataTable8_19
   \   00000012   0x6008             STR      R0,[R1, #+0]
    463                NRF_GPIOTE->EVENTS_IN[0] = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR      R1,??DataTable8_18  ;; 0x40006100
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \   0000001A   0xE020             B        ??GPIOTE_Handler_1
    464                }
    465          
    466                /* Checking Config #1 */
    467             else if (NRF_GPIOTE->EVENTS_IN[1])
   \                     ??GPIOTE_Handler_0: (+1)
   \   0000001C   0x....             LDR      R0,??DataTable8_20  ;; 0x40006104
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD008             BEQ      ??GPIOTE_Handler_2
    468                {
    469                MOTOR_Enc02Events++;
   \   00000024   0x....             LDR      R0,??DataTable8
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \   0000002A   0x....             LDR      R1,??DataTable8
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    470                NRF_GPIOTE->EVENTS_IN[1] = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x....             LDR      R1,??DataTable8_20  ;; 0x40006104
   \   00000032   0x6008             STR      R0,[R1, #+0]
   \   00000034   0xE013             B        ??GPIOTE_Handler_1
    471                }
    472          
    473                /*
    474                ** Checking Config #2 - Touch sensor IRQ. The interrupt will only fire once but
    475                ** it won't fire again until you read the touch sensor. So application has to
    476                ** respond to the IRQCounter and read the button states. That will allow the
    477                ** touch sensor to enable the interrupt pin again if there is more activity.
    478                */
    479             else if (NRF_GPIOTE->EVENTS_IN[2])
   \                     ??GPIOTE_Handler_2: (+1)
   \   00000036   0x....             LDR      R0,??DataTable8_21  ;; 0x40006108
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD008             BEQ      ??GPIOTE_Handler_3
    480                {
    481                NRF_GPIOTE->EVENTS_IN[2] = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x....             LDR      R1,??DataTable8_21  ;; 0x40006108
   \   00000042   0x6008             STR      R0,[R1, #+0]
    482                TS_IRQCounter++;
   \   00000044   0x....             LDR      R0,??DataTable8_22
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0x....             LDR      R1,??DataTable8_22
   \   0000004C   0x7008             STRB     R0,[R1, #+0]
   \   0000004E   0xE006             B        ??GPIOTE_Handler_1
    483                }
    484          
    485                   /* Checking Config #2 */
    486             else if (NRF_GPIOTE->EVENTS_IN[2])
   \                     ??GPIOTE_Handler_3: (+1)
   \   00000050   0x....             LDR      R0,??DataTable8_21  ;; 0x40006108
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ      ??GPIOTE_Handler_1
    487                {
    488                NRF_GPIOTE->EVENTS_IN[2] = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x....             LDR      R1,??DataTable8_21  ;; 0x40006108
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    489                }
    490          }
   \                     ??GPIOTE_Handler_1: (+1)
   \   0000005E   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0xE000ED1C         DC32     0xe000ed1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x50000740         DC32     0x50000740

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x5000073C         DC32     0x5000073c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x00011001         DC32     0x11001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40006510         DC32     0x40006510

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x00010F01         DC32     0x10f01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x40006514         DC32     0x40006514

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x40006304         DC32     0x40006304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     MOTOR_Enc01Events

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     mfgBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     MOTOR_Enc02Events

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x00001388         DC32     0x1388

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x00000802         DC32     0x802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x40007504         DC32     0x40007504

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x40007500         DC32     0x40007500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x40007100         DC32     0x40007100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x40007508         DC32     0x40007508

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x40007004         DC32     0x40007004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x00001389         DC32     0x1389

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_18:
   \   00000000   0x40006100         DC32     0x40006100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_19:
   \   00000000   0x........         DC32     MOTOR_Enc01Events

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_20:
   \   00000000   0x40006104         DC32     0x40006104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_21:
   \   00000000   0x40006108         DC32     0x40006108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_22:
   \   00000000   0x........         DC32     TS_IRQCounter

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x4D 0x6F          DC8 "Motor error step 1 %u\012"
   \              0x74 0x6F    
   \              0x72 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x73 0x74    
   \              0x65 0x70    
   \              0x20 0x31    
   \              0x20 0x25    
   \              0x75 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x4D 0x6F          DC8 "Motor error step 2 %u\012"
   \              0x74 0x6F    
   \              0x72 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x73 0x74    
   \              0x65 0x70    
   \              0x20 0x32    
   \              0x20 0x25    
   \              0x75 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x4D 0x6F          DC8 "Motor lock called with %u %u\012"
   \              0x74 0x6F    
   \              0x72 0x20    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x20 0x63    
   \              0x61 0x6C    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x25    
   \              0x75 0x20    
   \              0x25 0x75    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x57 0x72          DC8 "Write failed with %u\012"
   \              0x69 0x74    
   \              0x65 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x77    
   \              0x69 0x74    
   \              0x68 0x20    
   \              0x25 0x75    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x25 0x30          DC8 "%03u: %04u/%04u\012"
   \              0x33 0x75    
   \              0x3A 0x20    
   \              0x25 0x30    
   \              0x34 0x75    
   \              0x2F 0x25    
   \              0x30 0x34    
   \              0x75 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x45 0x6E          DC8 "Enc #1: %u   Enc #2: %u  Status: %02x %02x\012"
   \              0x63 0x20    
   \              0x23 0x31    
   \              0x3A 0x20    
   \              0x25 0x75    
   \              0x20 0x20    
   \              0x20 0x45    
   \              0x6E 0x63    
   \              0x20 0x23    
   \              0x32 0x3A    
   \              0x20 0x25    
   \              0x75 0x20    
   \              0x20 0x53    
   \              0x74 0x61    
   \              0x74 0x75    
   \              0x73 0x3A    
   \              0x20 0x25    
   \              0x30 0x32    
   \              0x78 0x20    
   \              0x25 0x30    
   \              0x32 0x78    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x54 0x6F          DC8 "Total steps requested and taken %u %u\012"
   \              0x74 0x61    
   \              0x6C 0x20    
   \              0x73 0x74    
   \              0x65 0x70    
   \              0x73 0x20    
   \              0x72 0x65    
   \              0x71 0x75    
   \              0x65 0x73    
   \              0x74 0x65    
   \              0x64 0x20    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x74 0x61    
   \              0x6B 0x65    
   \              0x6E 0x20    
   \              0x25 0x75    
   \              0x20 0x25    
   \              0x75 0x0A    
   \              0x00         
   \   00000027   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   GPIOTE_Handler
       4   Motor_ADC
      40   Motor_Lock
        40   -> Motor_Start
        40   -> Motor_Stop
        40   -> Timer2_Count
        40   -> printf
        40 __aeabi_idiv
       8   Motor_Setup
         8   -> I2C_Write
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_EnableIRQ
         8   -> NVIC_SetPriority
      16   Motor_Start
        16   -> I2C_Read
        16   -> I2C_Write
      16   Motor_Stop
        16   -> I2C_FullRead
        16   -> I2C_Write
        16   -> Timer2_Count
        16   -> printf
       0   NVIC_ClearPendingIRQ
       0   NVIC_EnableIRQ
      20   NVIC_SetPriority


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_20
       4  ??DataTable8_21
       4  ??DataTable8_22
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      24  ?_0
      24  ?_1
      32  ?_2
      24  ?_3
      20  ?_4
      44  ?_5
      40  ?_6
      96  GPIOTE_Handler
       4  MOTOR_Enc01Events
       4  MOTOR_Enc02Events
      54  Motor_ADC
     266  Motor_Lock
      82  Motor_Setup
      88  Motor_Start
     224  Motor_Stop
      14  NVIC_ClearPendingIRQ
      14  NVIC_EnableIRQ
     134  NVIC_SetPriority

 
     8 bytes in section .bss
   208 bytes in section .rodata
 1 116 bytes in section .text
 
 1 116 bytes of CODE  memory
   208 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: 1
