###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        16/Apr/2015  21:19:48
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\VeloLabs\SkyLock
#        Project\SDK_7_2_0\components\ble\common\ble_advdata.c
#    Command line =  
#        "C:\VeloLabs\SkyLock
#        Project\SDK_7_2_0\components\ble\common\ble_advdata.c" -D NRF51 -D
#        BLE_STACK_SUPPORT_REQD -lCN "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\Debug\List\" -o "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\Debug\Obj\" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Normal.h" -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\include\" -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\include\ARMFiles\" -I
#        "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\drivers_nrf\hal\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\softdevice\s110\headers\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\toolchain\" -I
#        "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\softdevice\common\softdevice_handler\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\util\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\scheduler\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\timer\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\ble\common\" -Ol
#    List file    =  
#        C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\Debug\List\ble_advdata.lst
#    Object file  =  
#        C:\VeloLabs\SkyLock Project\Source\IAR_7_30_4\Debug\Obj\ble_advdata.o
#
###############################################################################

C:\VeloLabs\SkyLock Project\SDK_7_2_0\components\ble\common\ble_advdata.c
      1          /* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
      2           *
      3           * The information contained herein is property of Nordic Semiconductor ASA.
      4           * Terms and conditions of usage are described in detail in NORDIC
      5           * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
      6           *
      7           * Licensees are granted free, non-transferable use of the information. NO
      8           * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
      9           * the file.
     10           *
     11           */
     12          
     13          #include "ble_advdata.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t uint16_encode(uint16_t, uint8_t *)
   \                     uint16_encode: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   \   00000002   0x700A             STRB     R2,[R1, #+0]
   \   00000004   0xB280             UXTH     R0,R0
   \   00000006   0x0A00             LSRS     R0,R0,#+8
   \   00000008   0x7048             STRB     R0,[R1, #+1]
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR               ;; return
     14          #include "nordic_common.h"
     15          #include "nrf_error.h"
     16          #include "ble_gap.h"
     17          #include "ble_srv_common.h"
     18          #include "app_util.h"
     19          
     20          
     21          // Offset from where advertisement data other than flags information can start.
     22          #define ADV_FLAG_OFFSET 2
     23          
     24          // Offset for Advertising Data.
     25          // Offset is 2 as each Advertising Data contain 1 octet of Adveritising Data Type and
     26          // one octet Advertising Data Length.
     27          #define ADV_DATA_OFFSET 2
     28          
     29          // NOTE: For now, Security Manager TK Value and Security Manager Out of Band Flags (OOB) are omitted
     30          //       from the advertising data.
     31          
     32          

   \                                 In section .text, align 2, keep-with-next
     33          static uint32_t name_encode(const ble_advdata_t * p_advdata,
     34                                      uint8_t             * p_encoded_data,
     35                                      uint8_t             * p_len)
     36          {
   \                     name_encode: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000B             MOVS     R3,R1
     37              uint32_t err_code;
     38              uint16_t rem_adv_data_len;
     39              uint16_t actual_length;
     40              uint8_t  adv_data_format;
     41              uint8_t  adv_offset;
     42          
     43              adv_offset = *p_len;
   \   00000008   0x7815             LDRB     R5,[R2, #+0]
     44          
     45          
     46              // Check for buffer overflow.
     47              if ((adv_offset + ADV_DATA_OFFSET > BLE_GAP_ADV_MAX_SIZE) ||
     48                  ((p_advdata->short_name_len + ADV_DATA_OFFSET) > BLE_GAP_ADV_MAX_SIZE))
   \   0000000A   0xB2ED             UXTB     R5,R5
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x1C80             ADDS     R0,R0,#+2
   \   00000010   0x2820             CMP      R0,#+32
   \   00000012   0xDA03             BGE      ??name_encode_0
   \   00000014   0x7860             LDRB     R0,[R4, #+1]
   \   00000016   0x1C80             ADDS     R0,R0,#+2
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xDB01             BLT      ??name_encode_1
     49              {
     50                  return NRF_ERROR_DATA_SIZE;
   \                     ??name_encode_0: (+1)
   \   0000001C   0x200C             MOVS     R0,#+12
   \   0000001E   0xE031             B        ??name_encode_2
     51              }
     52              actual_length = rem_adv_data_len = (BLE_GAP_ADV_MAX_SIZE - adv_offset - ADV_FLAG_OFFSET);
   \                     ??name_encode_1: (+1)
   \   00000020   0x201D             MOVS     R0,#+29
   \   00000022   0xB2ED             UXTB     R5,R5
   \   00000024   0x1B46             SUBS     R6,R0,R5
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x8006             STRH     R6,[R0, #+0]
     53          
     54              // Get GAP device name and length
     55              err_code = sd_ble_gap_device_name_get(&p_encoded_data[adv_offset + ADV_DATA_OFFSET],
     56                                                    &actual_length);
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0xB2ED             UXTB     R5,R5
   \   0000002E   0x1958             ADDS     R0,R3,R5
   \   00000030   0x1C80             ADDS     R0,R0,#+2
   \   00000032   0xDF7D             SVC      0x7D
     57              if (err_code != NRF_SUCCESS)
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD125             BNE      ??name_encode_2
     58              {
     59                  return err_code;
     60              }
     61              
     62              // Check if device internd to use short name and it can fit available data size.
     63              if ((p_advdata->name_type == BLE_ADVDATA_FULL_NAME) && (actual_length <= rem_adv_data_len))
   \                     ??name_encode_3: (+1)
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x2802             CMP      R0,#+2
   \   0000003C   0xD108             BNE      ??name_encode_4
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x8800             LDRH     R0,[R0, #+0]
   \   00000042   0xB2B6             UXTH     R6,R6
   \   00000044   0x4286             CMP      R6,R0
   \   00000046   0xD303             BCC      ??name_encode_4
     64              {
     65                  // Complete device name can fit, setting Complete Name in Adv Data.
     66                  adv_data_format  = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
   \   00000048   0x2009             MOVS     R0,#+9
     67                  rem_adv_data_len = actual_length;
   \   0000004A   0x4669             MOV      R1,SP
   \   0000004C   0x880E             LDRH     R6,[R1, #+0]
   \   0000004E   0xE00C             B        ??name_encode_5
     68              }
     69              else
     70              {
     71                  // Else short name needs to be used. Or application has requested use of short name.
     72                  adv_data_format = BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME;
   \                     ??name_encode_4: (+1)
   \   00000050   0x2008             MOVS     R0,#+8
     73          
     74                  // If application has set a preference on the short name size, it needs to be considered,
     75                  // else fit what can be fit.
     76                  if ((p_advdata->short_name_len != 0) && (p_advdata->short_name_len <= rem_adv_data_len))
   \   00000052   0x7861             LDRB     R1,[R4, #+1]
   \   00000054   0x2900             CMP      R1,#+0
   \   00000056   0xD006             BEQ      ??name_encode_6
   \   00000058   0x7861             LDRB     R1,[R4, #+1]
   \   0000005A   0xB2B6             UXTH     R6,R6
   \   0000005C   0xB289             UXTH     R1,R1
   \   0000005E   0x428E             CMP      R6,R1
   \   00000060   0xD301             BCC      ??name_encode_6
     77                  {
     78                      // Short name fits available size.
     79                      rem_adv_data_len = p_advdata->short_name_len;
   \   00000062   0x7866             LDRB     R6,[R4, #+1]
   \   00000064   0xE001             B        ??name_encode_5
     80                  }
     81                  // Else whatever can fit the data buffer will be packed.
     82                  else
     83                  {
     84                      rem_adv_data_len = actual_length;
   \                     ??name_encode_6: (+1)
   \   00000066   0x4669             MOV      R1,SP
   \   00000068   0x880E             LDRH     R6,[R1, #+0]
     85                  }
     86              }
     87          
     88              // Complete name field in encoded data.
     89              p_encoded_data[adv_offset++] = rem_adv_data_len + 1;
   \                     ??name_encode_5: (+1)
   \   0000006A   0x0031             MOVS     R1,R6
   \   0000006C   0x1C49             ADDS     R1,R1,#+1
   \   0000006E   0xB2ED             UXTB     R5,R5
   \   00000070   0x5559             STRB     R1,[R3, R5]
   \   00000072   0x1C6D             ADDS     R5,R5,#+1
     90              p_encoded_data[adv_offset++] = adv_data_format;
   \   00000074   0xB2ED             UXTB     R5,R5
   \   00000076   0x5558             STRB     R0,[R3, R5]
   \   00000078   0x1C6D             ADDS     R5,R5,#+1
     91              (*p_len)                    += (rem_adv_data_len + ADV_DATA_OFFSET);
   \   0000007A   0x7810             LDRB     R0,[R2, #+0]
   \   0000007C   0x1CB6             ADDS     R6,R6,#+2
   \   0000007E   0x1980             ADDS     R0,R0,R6
   \   00000080   0x7010             STRB     R0,[R2, #+0]
     92          
     93              return NRF_SUCCESS;
   \   00000082   0x2000             MOVS     R0,#+0
   \                     ??name_encode_2: (+1)
   \   00000084   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
     94          }
     95          
     96          

   \                                 In section .text, align 2, keep-with-next
     97          static uint32_t appearance_encode(uint8_t * p_encoded_data, uint8_t * p_len)
     98          {
   \                     appearance_encode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0002             MOVS     R2,R0
   \   00000006   0x000C             MOVS     R4,R1
     99              uint32_t err_code;
    100              uint16_t appearance;
    101          
    102              // Check for buffer overflow.
    103              if ((*p_len) + 4 > BLE_GAP_ADV_MAX_SIZE)
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x1D00             ADDS     R0,R0,#+4
   \   0000000C   0x2820             CMP      R0,#+32
   \   0000000E   0xDB01             BLT      ??appearance_encode_0
    104              {
    105                  return NRF_ERROR_DATA_SIZE;
   \   00000010   0x200C             MOVS     R0,#+12
   \   00000012   0xE01B             B        ??appearance_encode_1
    106              }
    107          
    108              // Get GAP appearance field.
    109              err_code = sd_ble_gap_appearance_get(&appearance);
   \                     ??appearance_encode_0: (+1)
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0xDF79             SVC      0x79
    110              if (err_code != NRF_SUCCESS)
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD117             BNE      ??appearance_encode_1
    111              {
    112                  return err_code;
    113              }
    114          
    115              // Encode Length, AD Type and Appearance.
    116              p_encoded_data[(*p_len)++] = 3;
   \                     ??appearance_encode_2: (+1)
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x0001             MOVS     R1,R0
   \   00000020   0x1C49             ADDS     R1,R1,#+1
   \   00000022   0x7021             STRB     R1,[R4, #+0]
   \   00000024   0x2103             MOVS     R1,#+3
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x5411             STRB     R1,[R2, R0]
    117              p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_APPEARANCE;
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x0001             MOVS     R1,R0
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \   00000030   0x7021             STRB     R1,[R4, #+0]
   \   00000032   0x2119             MOVS     R1,#+25
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0x5411             STRB     R1,[R2, R0]
    118          
    119              (*p_len) += uint16_encode(appearance, &p_encoded_data[*p_len]);
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x1811             ADDS     R1,R2,R0
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x8800             LDRH     R0,[R0, #+0]
   \   00000040   0x.... 0x....      BL       uint16_encode
   \   00000044   0x7821             LDRB     R1,[R4, #+0]
   \   00000046   0x1808             ADDS     R0,R1,R0
   \   00000048   0x7020             STRB     R0,[R4, #+0]
    120          
    121              return NRF_SUCCESS;
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??appearance_encode_1: (+1)
   \   0000004C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    122          }
    123          
    124          

   \                                 In section .text, align 2, keep-with-next
    125          static uint32_t uint8_array_encode(const uint8_array_t * p_uint8_array,
    126                                             uint8_t               adv_type,
    127                                             uint8_t             * p_encoded_data,
    128                                             uint8_t             * p_len)
    129          {
   \                     uint8_array_encode: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x001D             MOVS     R5,R3
    130              // Check parameter consistency.
    131              if (p_uint8_array->p_data == NULL)
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE      ??uint8_array_encode_0
    132              {
    133                  return NRF_ERROR_INVALID_PARAM;
   \   0000000C   0x2007             MOVS     R0,#+7
   \   0000000E   0xE022             B        ??uint8_array_encode_1
    134              }
    135          
    136              // Check for buffer overflow.
    137              if ((*p_len) + ADV_DATA_OFFSET + p_uint8_array->size > BLE_GAP_ADV_MAX_SIZE)
   \                     ??uint8_array_encode_0: (+1)
   \   00000010   0x7828             LDRB     R0,[R5, #+0]
   \   00000012   0x8823             LDRH     R3,[R4, #+0]
   \   00000014   0x18C0             ADDS     R0,R0,R3
   \   00000016   0x1C80             ADDS     R0,R0,#+2
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xDB01             BLT      ??uint8_array_encode_2
    138              {
    139                  return NRF_ERROR_DATA_SIZE;
   \   0000001C   0x200C             MOVS     R0,#+12
   \   0000001E   0xE01A             B        ??uint8_array_encode_1
    140              }
    141          
    142              // Encode Length and AD Type.
    143              p_encoded_data[(*p_len)++] = 1 + p_uint8_array->size;
   \                     ??uint8_array_encode_2: (+1)
   \   00000020   0x7828             LDRB     R0,[R5, #+0]
   \   00000022   0x0003             MOVS     R3,R0
   \   00000024   0x1C5B             ADDS     R3,R3,#+1
   \   00000026   0x702B             STRB     R3,[R5, #+0]
   \   00000028   0x8823             LDRH     R3,[R4, #+0]
   \   0000002A   0x1C5B             ADDS     R3,R3,#+1
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0x5413             STRB     R3,[R2, R0]
    144              p_encoded_data[(*p_len)++] = adv_type;
   \   00000030   0x7828             LDRB     R0,[R5, #+0]
   \   00000032   0x0003             MOVS     R3,R0
   \   00000034   0x1C5B             ADDS     R3,R3,#+1
   \   00000036   0x702B             STRB     R3,[R5, #+0]
   \   00000038   0xB2C0             UXTB     R0,R0
   \   0000003A   0x5411             STRB     R1,[R2, R0]
    145          
    146              // Encode array.
    147              memcpy(&p_encoded_data[*p_len], p_uint8_array->p_data, p_uint8_array->size);
   \   0000003C   0x8820             LDRH     R0,[R4, #+0]
   \   0000003E   0x6861             LDR      R1,[R4, #+4]
   \   00000040   0x782B             LDRB     R3,[R5, #+0]
   \   00000042   0x18D6             ADDS     R6,R2,R3
   \   00000044   0x0002             MOVS     R2,R0
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0x.... 0x....      BL       __aeabi_memcpy
    148              (*p_len) += p_uint8_array->size;
   \   0000004C   0x7828             LDRB     R0,[R5, #+0]
   \   0000004E   0x8821             LDRH     R1,[R4, #+0]
   \   00000050   0x1840             ADDS     R0,R0,R1
   \   00000052   0x7028             STRB     R0,[R5, #+0]
    149          
    150              return NRF_SUCCESS;
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??uint8_array_encode_1: (+1)
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    151          }
    152          
    153          

   \                                 In section .text, align 2, keep-with-next
    154          static uint32_t tx_power_level_encode(int8_t    tx_power_level,
    155                                                uint8_t * p_encoded_data,
    156                                                uint8_t * p_len)
    157          {
   \                     tx_power_level_encode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    158              // Check for buffer overflow.
    159              if ((*p_len) + 3 > BLE_GAP_ADV_MAX_SIZE)
   \   00000002   0x7813             LDRB     R3,[R2, #+0]
   \   00000004   0x1CDB             ADDS     R3,R3,#+3
   \   00000006   0x2B20             CMP      R3,#+32
   \   00000008   0xDB01             BLT      ??tx_power_level_encode_0
    160              {
    161                  return NRF_ERROR_DATA_SIZE;
   \   0000000A   0x200C             MOVS     R0,#+12
   \   0000000C   0xE014             B        ??tx_power_level_encode_1
    162              }
    163          
    164              // Encode TX Power Level.
    165              p_encoded_data[(*p_len)++] = 2;
   \                     ??tx_power_level_encode_0: (+1)
   \   0000000E   0x7813             LDRB     R3,[R2, #+0]
   \   00000010   0x001C             MOVS     R4,R3
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   \   00000014   0x7014             STRB     R4,[R2, #+0]
   \   00000016   0x2402             MOVS     R4,#+2
   \   00000018   0xB2DB             UXTB     R3,R3
   \   0000001A   0x54CC             STRB     R4,[R1, R3]
    166              p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_TX_POWER_LEVEL;
   \   0000001C   0x7813             LDRB     R3,[R2, #+0]
   \   0000001E   0x001C             MOVS     R4,R3
   \   00000020   0x1C64             ADDS     R4,R4,#+1
   \   00000022   0x7014             STRB     R4,[R2, #+0]
   \   00000024   0x240A             MOVS     R4,#+10
   \   00000026   0xB2DB             UXTB     R3,R3
   \   00000028   0x54CC             STRB     R4,[R1, R3]
    167              p_encoded_data[(*p_len)++] = (uint8_t)tx_power_level;
   \   0000002A   0x7813             LDRB     R3,[R2, #+0]
   \   0000002C   0x001C             MOVS     R4,R3
   \   0000002E   0x1C64             ADDS     R4,R4,#+1
   \   00000030   0x7014             STRB     R4,[R2, #+0]
   \   00000032   0xB2DB             UXTB     R3,R3
   \   00000034   0x54C8             STRB     R0,[R1, R3]
    168          
    169              return NRF_SUCCESS;
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??tx_power_level_encode_1: (+1)
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    170          }
    171          
    172          

   \                                 In section .text, align 2, keep-with-next
    173          static uint32_t uuid_list_sized_encode(const ble_advdata_uuid_list_t * p_uuid_list,
    174                                                 uint8_t                         adv_type,
    175                                                 uint8_t                         uuid_size,
    176                                                 uint8_t                       * p_encoded_data,
    177                                                 uint8_t                       * p_len)
    178          {
   \                     uuid_list_sized_encode: (+1)
   \   00000000   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    179              int     i;
    180              bool    is_heading_written = false;
   \   00000004   0x2600             MOVS     R6,#+0
   \   00000006   0x9C0A             LDR      R4,[SP, #+40]
    181              uint8_t start_pos          = *p_len;
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x7048             STRB     R0,[R1, #+1]
    182          
    183              for (i = 0; i < p_uuid_list->uuid_cnt; i++)
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xE005             B        ??uuid_list_sized_encode_0
    184              {
    185                  uint32_t   err_code;
    186                  uint8_t    encoded_size;
    187                  ble_uuid_t uuid = p_uuid_list->p_uuids[i];
    188                  
    189                  // Find encoded uuid size.
    190                  err_code = sd_ble_uuid_encode(&uuid, &encoded_size, NULL);
    191                  if (err_code != NRF_SUCCESS)
    192                  {
    193                      return err_code;
    194                  }
    195          
    196                  // Check size.
    197                  if (encoded_size == uuid_size)
    198                  {
    199                      uint8_t heading_bytes = (is_heading_written) ? 0 : 2;
    200                      
    201                      // Check for buffer overflow
    202                      if (*p_len + encoded_size + heading_bytes > BLE_GAP_ADV_MAX_SIZE)
    203                      {
    204                          return NRF_ERROR_DATA_SIZE;
    205                      }
    206          
    207                      if (!is_heading_written)
    208                      {
    209                          // Write AD structure heading.
    210                          (*p_len)++;
    211                          p_encoded_data[(*p_len)++] = adv_type;
    212                          is_heading_written         = true;
    213                      }
    214          
    215                      // Write UUID.
    216                      err_code = sd_ble_uuid_encode(&uuid, &encoded_size, &p_encoded_data[*p_len]);
    217                      if (err_code != NRF_SUCCESS)
    218                      {
    219                          return err_code;
    220                      }
    221                      (*p_len) += encoded_size;
   \                     ??uuid_list_sized_encode_1: (+1)
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x7809             LDRB     R1,[R1, #+0]
   \   00000018   0x1840             ADDS     R0,R0,R1
   \   0000001A   0x7020             STRB     R0,[R4, #+0]
   \                     ??uuid_list_sized_encode_2: (+1)
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uuid_list_sized_encode_0: (+1)
   \   0000001E   0x9802             LDR      R0,[SP, #+8]
   \   00000020   0x8800             LDRH     R0,[R0, #+0]
   \   00000022   0x4285             CMP      R5,R0
   \   00000024   0xDA3C             BGE      ??uuid_list_sized_encode_3
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x9902             LDR      R1,[SP, #+8]
   \   0000002A   0x6849             LDR      R1,[R1, #+4]
   \   0000002C   0x2204             MOVS     R2,#+4
   \   0000002E   0x436A             MULS     R2,R5,R2
   \   00000030   0x1889             ADDS     R1,R1,R2
   \   00000032   0x880A             LDRH     R2,[R1, #0]
   \   00000034   0x8002             STRH     R2,[R0, #0]
   \   00000036   0x884A             LDRH     R2,[R1, #+2]
   \   00000038   0x8042             STRH     R2,[R0, #+2]
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0xA801             ADD      R0,SP,#+4
   \   00000040   0xDF65             SVC      0x65
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD138             BNE      ??uuid_list_sized_encode_4
   \                     ??uuid_list_sized_encode_5: (+1)
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x4669             MOV      R1,SP
   \   0000004C   0x7C09             LDRB     R1,[R1, #+16]
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD1E4             BNE      ??uuid_list_sized_encode_2
   \   00000052   0xB2F6             UXTB     R6,R6
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD001             BEQ      ??uuid_list_sized_encode_6
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE000             B        ??uuid_list_sized_encode_7
   \                     ??uuid_list_sized_encode_6: (+1)
   \   0000005C   0x2002             MOVS     R0,#+2
   \                     ??uuid_list_sized_encode_7: (+1)
   \   0000005E   0x7821             LDRB     R1,[R4, #+0]
   \   00000060   0x466A             MOV      R2,SP
   \   00000062   0x7812             LDRB     R2,[R2, #+0]
   \   00000064   0x1889             ADDS     R1,R1,R2
   \   00000066   0xB2C0             UXTB     R0,R0
   \   00000068   0x1808             ADDS     R0,R1,R0
   \   0000006A   0x2820             CMP      R0,#+32
   \   0000006C   0xDB01             BLT      ??uuid_list_sized_encode_8
   \   0000006E   0x200C             MOVS     R0,#+12
   \   00000070   0xE022             B        ??uuid_list_sized_encode_4
   \                     ??uuid_list_sized_encode_8: (+1)
   \   00000072   0xB2F6             UXTB     R6,R6
   \   00000074   0x2E00             CMP      R6,#+0
   \   00000076   0xD10B             BNE      ??uuid_list_sized_encode_9
   \   00000078   0x7820             LDRB     R0,[R4, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x7020             STRB     R0,[R4, #+0]
   \   0000007E   0x7820             LDRB     R0,[R4, #+0]
   \   00000080   0x0001             MOVS     R1,R0
   \   00000082   0x1C49             ADDS     R1,R1,#+1
   \   00000084   0x7021             STRB     R1,[R4, #+0]
   \   00000086   0x4669             MOV      R1,SP
   \   00000088   0x7B09             LDRB     R1,[R1, #+12]
   \   0000008A   0xB2C0             UXTB     R0,R0
   \   0000008C   0x5419             STRB     R1,[R3, R0]
   \   0000008E   0x2601             MOVS     R6,#+1
   \                     ??uuid_list_sized_encode_9: (+1)
   \   00000090   0x7820             LDRB     R0,[R4, #+0]
   \   00000092   0x181A             ADDS     R2,R3,R0
   \   00000094   0x4669             MOV      R1,SP
   \   00000096   0xA801             ADD      R0,SP,#+4
   \   00000098   0xDF65             SVC      0x65
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD0B9             BEQ      ??uuid_list_sized_encode_1
   \   0000009E   0xE00B             B        ??uuid_list_sized_encode_4
    222                  }
    223              }
    224          
    225              if (is_heading_written)
   \                     ??uuid_list_sized_encode_3: (+1)
   \   000000A0   0xB2F6             UXTB     R6,R6
   \   000000A2   0x2E00             CMP      R6,#+0
   \   000000A4   0xD007             BEQ      ??uuid_list_sized_encode_10
    226              {
    227                  // Write length.
    228                  p_encoded_data[start_pos] = (*p_len) - (start_pos + 1);
   \   000000A6   0x7820             LDRB     R0,[R4, #+0]
   \   000000A8   0x4669             MOV      R1,SP
   \   000000AA   0x7849             LDRB     R1,[R1, #+1]
   \   000000AC   0x1A40             SUBS     R0,R0,R1
   \   000000AE   0x1E40             SUBS     R0,R0,#+1
   \   000000B0   0x4669             MOV      R1,SP
   \   000000B2   0x7849             LDRB     R1,[R1, #+1]
   \   000000B4   0x5458             STRB     R0,[R3, R1]
    229              }
    230          
    231              return NRF_SUCCESS;
   \                     ??uuid_list_sized_encode_10: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \                     ??uuid_list_sized_encode_4: (+1)
   \   000000B8   0xB005             ADD      SP,SP,#+20
   \   000000BA   0xBDF0             POP      {R4-R7,PC}       ;; return
    232          }
    233          
    234          

   \                                 In section .text, align 2, keep-with-next
    235          static uint32_t uuid_list_encode(const ble_advdata_uuid_list_t * p_uuid_list,
    236                                           uint8_t                         adv_type_16,
    237                                           uint8_t                         adv_type_128,
    238                                           uint8_t                       * p_encoded_data,
    239                                           uint8_t                       * p_len)
    240          {
   \                     uuid_list_encode: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x001F             MOVS     R7,R3
   \   00000008   0x9C06             LDR      R4,[SP, #+24]
    241              uint32_t err_code;
    242          
    243              // Encode 16 bit UUIDs.
    244              err_code = uuid_list_sized_encode(p_uuid_list,
    245                                                adv_type_16,
    246                                                sizeof(uint16_le_t),
    247                                                p_encoded_data,
    248                                                p_len);
   \   0000000A   0x9400             STR      R4,[SP, #+0]
   \   0000000C   0x003B             MOVS     R3,R7
   \   0000000E   0x2202             MOVS     R2,#+2
   \   00000010   0xB2C9             UXTB     R1,R1
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       uuid_list_sized_encode
    249              if (err_code != NRF_SUCCESS)
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD10A             BNE      ??uuid_list_encode_0
    250              {
    251                  return err_code;
    252              }
    253          
    254              // Encode 128 bit UUIDs.
    255              err_code = uuid_list_sized_encode(p_uuid_list,
    256                                                adv_type_128,
    257                                                sizeof(ble_uuid128_t),
    258                                                p_encoded_data,
    259                                                p_len);
   \                     ??uuid_list_encode_1: (+1)
   \   0000001C   0x9400             STR      R4,[SP, #+0]
   \   0000001E   0x003B             MOVS     R3,R7
   \   00000020   0x2210             MOVS     R2,#+16
   \   00000022   0x0031             MOVS     R1,R6
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x.... 0x....      BL       uuid_list_sized_encode
    260              if (err_code != NRF_SUCCESS)
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD100             BNE      ??uuid_list_encode_0
    261              {
    262                  return err_code;
    263              }
    264          
    265              return NRF_SUCCESS;
   \                     ??uuid_list_encode_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??uuid_list_encode_0: (+1)
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    266          }
    267          
    268          

   \                                 In section .text, align 2, keep-with-next
    269          static uint32_t conn_int_check(const ble_advdata_conn_int_t *p_conn_int)
    270          {
   \                     conn_int_check: (+1)
   \   00000000   0xB500             PUSH     {LR}
    271              // Check Minimum Connection Interval.
    272              if ((p_conn_int->min_conn_interval < 0x0006) ||
    273                  (
    274                      (p_conn_int->min_conn_interval > 0x0c80) &&
    275                      (p_conn_int->min_conn_interval != 0xffff)
    276                  )
    277                 )
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0x2906             CMP      R1,#+6
   \   00000006   0xDB07             BLT      ??conn_int_check_0
   \   00000008   0x8801             LDRH     R1,[R0, #+0]
   \   0000000A   0x....             LDR      R2,??DataTable0  ;; 0xc81
   \   0000000C   0x4291             CMP      R1,R2
   \   0000000E   0xDB05             BLT      ??conn_int_check_1
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0x....             LDR      R2,??DataTable0_1  ;; 0xffff
   \   00000014   0x4291             CMP      R1,R2
   \   00000016   0xD001             BEQ      ??conn_int_check_1
    278              {
    279                  return NRF_ERROR_INVALID_PARAM;
   \                     ??conn_int_check_0: (+1)
   \   00000018   0x2007             MOVS     R0,#+7
   \   0000001A   0xE01B             B        ??conn_int_check_2
    280              }
    281          
    282              // Check Maximum Connection Interval.
    283              if ((p_conn_int->max_conn_interval < 0x0006) || 
    284                  (
    285                      (p_conn_int->max_conn_interval > 0x0c80) && 
    286                      (p_conn_int->max_conn_interval != 0xffff)
    287                  )
    288                 )
   \                     ??conn_int_check_1: (+1)
   \   0000001C   0x8841             LDRH     R1,[R0, #+2]
   \   0000001E   0x2906             CMP      R1,#+6
   \   00000020   0xDB07             BLT      ??conn_int_check_3
   \   00000022   0x8841             LDRH     R1,[R0, #+2]
   \   00000024   0x....             LDR      R2,??DataTable0  ;; 0xc81
   \   00000026   0x4291             CMP      R1,R2
   \   00000028   0xDB05             BLT      ??conn_int_check_4
   \   0000002A   0x8841             LDRH     R1,[R0, #+2]
   \   0000002C   0x....             LDR      R2,??DataTable0_1  ;; 0xffff
   \   0000002E   0x4291             CMP      R1,R2
   \   00000030   0xD001             BEQ      ??conn_int_check_4
    289              {
    290                  return NRF_ERROR_INVALID_PARAM;
   \                     ??conn_int_check_3: (+1)
   \   00000032   0x2007             MOVS     R0,#+7
   \   00000034   0xE00E             B        ??conn_int_check_2
    291              }
    292          
    293              // Make sure Minimum Connection Interval is not bigger than Maximum Connection Interval.
    294              if ((p_conn_int->min_conn_interval != 0xffff) &&
    295                  (p_conn_int->max_conn_interval != 0xffff) &&
    296                  (p_conn_int->min_conn_interval > p_conn_int->max_conn_interval)
    297                  )
   \                     ??conn_int_check_4: (+1)
   \   00000036   0x8801             LDRH     R1,[R0, #+0]
   \   00000038   0x....             LDR      R2,??DataTable0_1  ;; 0xffff
   \   0000003A   0x4291             CMP      R1,R2
   \   0000003C   0xD009             BEQ      ??conn_int_check_5
   \   0000003E   0x8841             LDRH     R1,[R0, #+2]
   \   00000040   0x....             LDR      R2,??DataTable0_1  ;; 0xffff
   \   00000042   0x4291             CMP      R1,R2
   \   00000044   0xD005             BEQ      ??conn_int_check_5
   \   00000046   0x8841             LDRH     R1,[R0, #+2]
   \   00000048   0x8800             LDRH     R0,[R0, #+0]
   \   0000004A   0x4281             CMP      R1,R0
   \   0000004C   0xD201             BCS      ??conn_int_check_5
    298              {
    299                  return NRF_ERROR_INVALID_PARAM;
   \   0000004E   0x2007             MOVS     R0,#+7
   \   00000050   0xE000             B        ??conn_int_check_2
    300              }
    301          
    302              return NRF_SUCCESS;
   \                     ??conn_int_check_5: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??conn_int_check_2: (+1)
   \   00000054   0xBD00             POP      {PC}             ;; return
    303          }
    304          
    305          

   \                                 In section .text, align 2, keep-with-next
    306          static uint32_t conn_int_encode(const ble_advdata_conn_int_t * p_conn_int,
    307                                          uint8_t                      * p_encoded_data,
    308                                          uint8_t                      * p_len)
    309          {
   \                     conn_int_encode: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
    310              uint32_t err_code;
    311          
    312              // Check for buffer overflow.
    313              if ((*p_len) + ADV_DATA_OFFSET + 2 * sizeof(uint16_le_t) > BLE_GAP_ADV_MAX_SIZE)
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x1D80             ADDS     R0,R0,#+6
   \   0000000C   0x2820             CMP      R0,#+32
   \   0000000E   0xD301             BCC      ??conn_int_encode_0
    314              {
    315                  return NRF_ERROR_DATA_SIZE;
   \   00000010   0x200C             MOVS     R0,#+12
   \   00000012   0xE023             B        ??conn_int_encode_1
    316              }
    317          
    318              // Check parameters.
    319              err_code = conn_int_check(p_conn_int);
   \                     ??conn_int_encode_0: (+1)
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       conn_int_check
    320              if (err_code != NRF_SUCCESS)
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD11E             BNE      ??conn_int_encode_1
    321              {
    322                  return err_code;
    323              }
    324          
    325              // Encode Length and AD Type.
    326              p_encoded_data[(*p_len)++] = 1 + 2 * sizeof(uint16_le_t);
   \                     ??conn_int_encode_2: (+1)
   \   0000001E   0x7828             LDRB     R0,[R5, #+0]
   \   00000020   0x0001             MOVS     R1,R0
   \   00000022   0x1C49             ADDS     R1,R1,#+1
   \   00000024   0x7029             STRB     R1,[R5, #+0]
   \   00000026   0x2105             MOVS     R1,#+5
   \   00000028   0xB2C0             UXTB     R0,R0
   \   0000002A   0x5421             STRB     R1,[R4, R0]
    327              p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE;
   \   0000002C   0x7828             LDRB     R0,[R5, #+0]
   \   0000002E   0x0001             MOVS     R1,R0
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \   00000032   0x7029             STRB     R1,[R5, #+0]
   \   00000034   0x2112             MOVS     R1,#+18
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0x5421             STRB     R1,[R4, R0]
    328          
    329              // Encode Minimum and Maximum Connection Intervals.
    330              (*p_len) += uint16_encode(p_conn_int->min_conn_interval, &p_encoded_data[*p_len]);
   \   0000003A   0x7828             LDRB     R0,[R5, #+0]
   \   0000003C   0x1821             ADDS     R1,R4,R0
   \   0000003E   0x8830             LDRH     R0,[R6, #+0]
   \   00000040   0x.... 0x....      BL       uint16_encode
   \   00000044   0x7829             LDRB     R1,[R5, #+0]
   \   00000046   0x1808             ADDS     R0,R1,R0
   \   00000048   0x7028             STRB     R0,[R5, #+0]
    331              (*p_len) += uint16_encode(p_conn_int->max_conn_interval, &p_encoded_data[*p_len]);
   \   0000004A   0x7828             LDRB     R0,[R5, #+0]
   \   0000004C   0x1821             ADDS     R1,R4,R0
   \   0000004E   0x8870             LDRH     R0,[R6, #+2]
   \   00000050   0x.... 0x....      BL       uint16_encode
   \   00000054   0x7829             LDRB     R1,[R5, #+0]
   \   00000056   0x1808             ADDS     R0,R1,R0
   \   00000058   0x7028             STRB     R0,[R5, #+0]
    332          
    333              return NRF_SUCCESS;
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??conn_int_encode_1: (+1)
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    334          }
    335          
    336          

   \                                 In section .text, align 2, keep-with-next
    337          static uint32_t manuf_specific_data_encode(const ble_advdata_manuf_data_t * p_manuf_sp_data,
    338                                                     uint8_t                        * p_encoded_data,
    339                                                     uint8_t                        * p_len)
    340          {
   \                     manuf_specific_data_encode: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0016             MOVS     R6,R2
    341              uint8_t data_size = sizeof(uint16_le_t) + p_manuf_sp_data->data.size;
   \   00000008   0x88A8             LDRH     R0,[R5, #+4]
   \   0000000A   0x1C80             ADDS     R0,R0,#+2
    342          
    343              // Check for buffer overflow.
    344              if ((*p_len) + ADV_DATA_OFFSET + data_size > BLE_GAP_ADV_MAX_SIZE)
   \   0000000C   0x7831             LDRB     R1,[R6, #+0]
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x1809             ADDS     R1,R1,R0
   \   00000012   0x1C89             ADDS     R1,R1,#+2
   \   00000014   0x2920             CMP      R1,#+32
   \   00000016   0xDB01             BLT      ??manuf_specific_data_encode_0
    345              {
    346                  return NRF_ERROR_DATA_SIZE;
   \   00000018   0x200C             MOVS     R0,#+12
   \   0000001A   0xE029             B        ??manuf_specific_data_encode_1
    347              }
    348          
    349              // Encode Length and AD Type.
    350              p_encoded_data[(*p_len)++] = 1 + data_size;
   \                     ??manuf_specific_data_encode_0: (+1)
   \   0000001C   0x7831             LDRB     R1,[R6, #+0]
   \   0000001E   0x000A             MOVS     R2,R1
   \   00000020   0x1C52             ADDS     R2,R2,#+1
   \   00000022   0x7032             STRB     R2,[R6, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0xB2C9             UXTB     R1,R1
   \   00000028   0x5460             STRB     R0,[R4, R1]
    351              p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
   \   0000002A   0x7830             LDRB     R0,[R6, #+0]
   \   0000002C   0x0001             MOVS     R1,R0
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \   00000030   0x7031             STRB     R1,[R6, #+0]
   \   00000032   0x21FF             MOVS     R1,#+255
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0x5421             STRB     R1,[R4, R0]
    352              
    353              // Encode Company Identifier.
    354              (*p_len) += uint16_encode(p_manuf_sp_data->company_identifier, &p_encoded_data[*p_len]);
   \   00000038   0x7830             LDRB     R0,[R6, #+0]
   \   0000003A   0x1821             ADDS     R1,R4,R0
   \   0000003C   0x8828             LDRH     R0,[R5, #+0]
   \   0000003E   0x.... 0x....      BL       uint16_encode
   \   00000042   0x7831             LDRB     R1,[R6, #+0]
   \   00000044   0x1808             ADDS     R0,R1,R0
   \   00000046   0x7030             STRB     R0,[R6, #+0]
    355              
    356              // Encode additional manufacturer specific data.
    357              if (p_manuf_sp_data->data.size > 0)
   \   00000048   0x88A8             LDRH     R0,[R5, #+4]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD00F             BEQ      ??manuf_specific_data_encode_2
    358              {
    359                  if (p_manuf_sp_data->data.p_data == NULL)
   \   0000004E   0x68A8             LDR      R0,[R5, #+8]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD101             BNE      ??manuf_specific_data_encode_3
    360                  {
    361                      return NRF_ERROR_INVALID_PARAM;
   \   00000054   0x2007             MOVS     R0,#+7
   \   00000056   0xE00B             B        ??manuf_specific_data_encode_1
    362                  }
    363                  memcpy(&p_encoded_data[*p_len], p_manuf_sp_data->data.p_data, p_manuf_sp_data->data.size);
   \                     ??manuf_specific_data_encode_3: (+1)
   \   00000058   0x88AA             LDRH     R2,[R5, #+4]
   \   0000005A   0x68A9             LDR      R1,[R5, #+8]
   \   0000005C   0x7830             LDRB     R0,[R6, #+0]
   \   0000005E   0x1824             ADDS     R4,R4,R0
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       __aeabi_memcpy
    364                  (*p_len) += p_manuf_sp_data->data.size;
   \   00000066   0x7830             LDRB     R0,[R6, #+0]
   \   00000068   0x88A9             LDRH     R1,[R5, #+4]
   \   0000006A   0x1840             ADDS     R0,R0,R1
   \   0000006C   0x7030             STRB     R0,[R6, #+0]
    365              }
    366          
    367              return NRF_SUCCESS;
   \                     ??manuf_specific_data_encode_2: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??manuf_specific_data_encode_1: (+1)
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
    368          }
    369          
    370          

   \                                 In section .text, align 2, keep-with-next
    371          static uint32_t service_data_encode(const ble_advdata_t * p_advdata,
    372                                              uint8_t             * p_encoded_data,
    373                                              uint8_t             * p_len)
    374          {
   \                     service_data_encode: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0016             MOVS     R6,R2
    375              uint8_t i;
    376          
    377              // Check parameter consistency.
    378              if (p_advdata->p_service_data_array == NULL)
   \   00000006   0x9801             LDR      R0,[SP, #+4]
   \   00000008   0x6B00             LDR      R0,[R0, #+48]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE      ??service_data_encode_0
    379              {
    380                  return NRF_ERROR_INVALID_PARAM;
   \   0000000E   0x2007             MOVS     R0,#+7
   \   00000010   0xE03E             B        ??service_data_encode_1
    381              }
    382          
    383              for (i = 0; i < p_advdata->service_data_count; i++)
   \                     ??service_data_encode_0: (+1)
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0xE00C             B        ??service_data_encode_2
    384              {
    385                  ble_advdata_service_data_t * p_service_data;
    386                  uint8_t                      data_size;
    387          
    388                  p_service_data = &p_advdata->p_service_data_array[i];
    389                  data_size      = sizeof(uint16_le_t) + p_service_data->data.size;
    390          
    391                  // Encode Length and AD Type.
    392                  p_encoded_data[(*p_len)++] = 1 + data_size;
    393                  p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_SERVICE_DATA;
    394          
    395                  // Encode service UUID.
    396                  (*p_len) += uint16_encode(p_service_data->service_uuid, &p_encoded_data[*p_len]);
    397          
    398                  // Encode additional service data.
    399                  if (p_service_data->data.size > 0)
    400                  {
    401                      if (p_service_data->data.p_data == NULL)
    402                      {
    403                          return NRF_ERROR_INVALID_PARAM;
    404                      }
    405                      memcpy(&p_encoded_data[*p_len], p_service_data->data.p_data, p_service_data->data.size);
   \                     ??service_data_encode_3: (+1)
   \   00000016   0x88A2             LDRH     R2,[R4, #+4]
   \   00000018   0x68A1             LDR      R1,[R4, #+8]
   \   0000001A   0x9802             LDR      R0,[SP, #+8]
   \   0000001C   0x7833             LDRB     R3,[R6, #+0]
   \   0000001E   0x18C7             ADDS     R7,R0,R3
   \   00000020   0x0038             MOVS     R0,R7
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy
    406                      (*p_len) += p_service_data->data.size;
   \   00000026   0x7830             LDRB     R0,[R6, #+0]
   \   00000028   0x88A1             LDRH     R1,[R4, #+4]
   \   0000002A   0x1840             ADDS     R0,R0,R1
   \   0000002C   0x7030             STRB     R0,[R6, #+0]
   \                     ??service_data_encode_4: (+1)
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??service_data_encode_2: (+1)
   \   00000030   0x9801             LDR      R0,[SP, #+4]
   \   00000032   0x3034             ADDS     R0,R0,#+52
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0xB2ED             UXTB     R5,R5
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD228             BCS      ??service_data_encode_5
   \   0000003C   0x9801             LDR      R0,[SP, #+4]
   \   0000003E   0x6B00             LDR      R0,[R0, #+48]
   \   00000040   0xB2ED             UXTB     R5,R5
   \   00000042   0x210C             MOVS     R1,#+12
   \   00000044   0x4369             MULS     R1,R5,R1
   \   00000046   0x1844             ADDS     R4,R0,R1
   \   00000048   0x88A0             LDRH     R0,[R4, #+4]
   \   0000004A   0x1C80             ADDS     R0,R0,#+2
   \   0000004C   0x7831             LDRB     R1,[R6, #+0]
   \   0000004E   0x000A             MOVS     R2,R1
   \   00000050   0x1C52             ADDS     R2,R2,#+1
   \   00000052   0x7032             STRB     R2,[R6, #+0]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0x9A02             LDR      R2,[SP, #+8]
   \   00000058   0xB2C9             UXTB     R1,R1
   \   0000005A   0x5450             STRB     R0,[R2, R1]
   \   0000005C   0x7830             LDRB     R0,[R6, #+0]
   \   0000005E   0x0001             MOVS     R1,R0
   \   00000060   0x1C49             ADDS     R1,R1,#+1
   \   00000062   0x7031             STRB     R1,[R6, #+0]
   \   00000064   0x2116             MOVS     R1,#+22
   \   00000066   0x9A02             LDR      R2,[SP, #+8]
   \   00000068   0xB2C0             UXTB     R0,R0
   \   0000006A   0x5411             STRB     R1,[R2, R0]
   \   0000006C   0x9802             LDR      R0,[SP, #+8]
   \   0000006E   0x7831             LDRB     R1,[R6, #+0]
   \   00000070   0x1841             ADDS     R1,R0,R1
   \   00000072   0x8820             LDRH     R0,[R4, #+0]
   \   00000074   0x.... 0x....      BL       uint16_encode
   \   00000078   0x7831             LDRB     R1,[R6, #+0]
   \   0000007A   0x1808             ADDS     R0,R1,R0
   \   0000007C   0x7030             STRB     R0,[R6, #+0]
   \   0000007E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD0D4             BEQ      ??service_data_encode_4
   \   00000084   0x68A0             LDR      R0,[R4, #+8]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD1C5             BNE      ??service_data_encode_3
   \   0000008A   0x2007             MOVS     R0,#+7
   \   0000008C   0xE000             B        ??service_data_encode_1
    407                  }
    408              }
    409          
    410              return NRF_SUCCESS;
   \                     ??service_data_encode_5: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \                     ??service_data_encode_1: (+1)
   \   00000090   0xBDFE             POP      {R1-R7,PC}       ;; return
    411          }
    412          
    413          

   \                                 In section .text, align 2, keep-with-next
    414          static uint32_t adv_data_encode(const ble_advdata_t * p_advdata,
    415                                          uint8_t             * p_encoded_data,
    416                                          uint8_t             * p_len)
    417          {
   \                     adv_data_encode: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
    418              uint32_t err_code = NRF_SUCCESS;
   \   0000000A   0x2000             MOVS     R0,#+0
    419          
    420              *p_len = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7029             STRB     R1,[R5, #+0]
    421          
    422              // Encode name.
    423              if (p_advdata->name_type != BLE_ADVDATA_NO_NAME)
   \   00000010   0x7821             LDRB     R1,[R4, #+0]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD006             BEQ      ??adv_data_encode_0
    424              {
    425                  err_code = name_encode(p_advdata, p_encoded_data, p_len);
   \   00000016   0x002A             MOVS     R2,R5
   \   00000018   0x0031             MOVS     R1,R6
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       name_encode
    426                  if (err_code != NRF_SUCCESS)
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD166             BNE      ??adv_data_encode_1
    427                  {
    428                      return err_code;
    429                  }
    430              }
    431          
    432              // Encode appearance.
    433              if (p_advdata->include_appearance)
   \                     ??adv_data_encode_0: (+1)
   \   00000024   0x78A1             LDRB     R1,[R4, #+2]
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD005             BEQ      ??adv_data_encode_2
    434              {
    435                  err_code = appearance_encode(p_encoded_data, p_len);
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      BL       appearance_encode
    436                  if (err_code != NRF_SUCCESS)
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD15D             BNE      ??adv_data_encode_1
    437                  {
    438                      return err_code;
    439                  }
    440              }
    441          
    442              // Encode flags.
    443              if (p_advdata->flags.size > 0)
   \                     ??adv_data_encode_2: (+1)
   \   00000036   0x88A1             LDRH     R1,[R4, #+4]
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD008             BEQ      ??adv_data_encode_3
    444              {
    445                  err_code = uint8_array_encode(&p_advdata->flags,
    446                                                BLE_GAP_AD_TYPE_FLAGS,
    447                                                p_encoded_data,
    448                                                p_len);
   \   0000003C   0x002B             MOVS     R3,R5
   \   0000003E   0x0032             MOVS     R2,R6
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x1D00             ADDS     R0,R0,#+4
   \   00000046   0x.... 0x....      BL       uint8_array_encode
    449                  if (err_code != NRF_SUCCESS)
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD151             BNE      ??adv_data_encode_1
    450                  {
    451                      return err_code;
    452                  }
    453              }
    454          
    455              // Encode TX power level.
    456              if (p_advdata->p_tx_power_level != NULL)
   \                     ??adv_data_encode_3: (+1)
   \   0000004E   0x68E1             LDR      R1,[R4, #+12]
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0xD008             BEQ      ??adv_data_encode_4
    457              {
    458                  err_code = tx_power_level_encode(*p_advdata->p_tx_power_level, p_encoded_data, p_len);
   \   00000054   0x002A             MOVS     R2,R5
   \   00000056   0x0031             MOVS     R1,R6
   \   00000058   0x68E0             LDR      R0,[R4, #+12]
   \   0000005A   0x2300             MOVS     R3,#+0
   \   0000005C   0x56C0             LDRSB    R0,[R0, R3]
   \   0000005E   0x.... 0x....      BL       tx_power_level_encode
    459                  if (err_code != NRF_SUCCESS)
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD145             BNE      ??adv_data_encode_1
    460                  {
    461                      return err_code;
    462                  }
    463              }
    464              
    465              // Encode 'more available' uuid list.
    466              if (p_advdata->uuids_more_available.uuid_cnt > 0)
   \                     ??adv_data_encode_4: (+1)
   \   00000066   0x8A21             LDRH     R1,[R4, #+16]
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD009             BEQ      ??adv_data_encode_5
    467              {
    468                  err_code = uuid_list_encode(&p_advdata->uuids_more_available,
    469                                              BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE,
    470                                              BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE,
    471                                              p_encoded_data,
    472                                              p_len);
   \   0000006C   0x9500             STR      R5,[SP, #+0]
   \   0000006E   0x0033             MOVS     R3,R6
   \   00000070   0x2206             MOVS     R2,#+6
   \   00000072   0x2102             MOVS     R1,#+2
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x3010             ADDS     R0,R0,#+16
   \   00000078   0x.... 0x....      BL       uuid_list_encode
    473                  if (err_code != NRF_SUCCESS)
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD138             BNE      ??adv_data_encode_1
    474                  {
    475                      return err_code;
    476                  }
    477              }
    478          
    479              // Encode 'complete' uuid list.
    480              if (p_advdata->uuids_complete.uuid_cnt > 0)
   \                     ??adv_data_encode_5: (+1)
   \   00000080   0x8B21             LDRH     R1,[R4, #+24]
   \   00000082   0x2900             CMP      R1,#+0
   \   00000084   0xD009             BEQ      ??adv_data_encode_6
    481              {
    482                  err_code = uuid_list_encode(&p_advdata->uuids_complete,
    483                                              BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
    484                                              BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE,
    485                                              p_encoded_data,
    486                                              p_len);
   \   00000086   0x9500             STR      R5,[SP, #+0]
   \   00000088   0x0033             MOVS     R3,R6
   \   0000008A   0x2207             MOVS     R2,#+7
   \   0000008C   0x2103             MOVS     R1,#+3
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x3018             ADDS     R0,R0,#+24
   \   00000092   0x.... 0x....      BL       uuid_list_encode
    487                  if (err_code != NRF_SUCCESS)
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD12B             BNE      ??adv_data_encode_1
    488                  {
    489                      return err_code;
    490                  }
    491              }
    492          
    493              // Encode 'solicited service' uuid list.
    494              if (p_advdata->uuids_solicited.uuid_cnt > 0)
   \                     ??adv_data_encode_6: (+1)
   \   0000009A   0x8C21             LDRH     R1,[R4, #+32]
   \   0000009C   0x2900             CMP      R1,#+0
   \   0000009E   0xD009             BEQ      ??adv_data_encode_7
    495              {
    496                  err_code = uuid_list_encode(&p_advdata->uuids_solicited,
    497                                              BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT,
    498                                              BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT,
    499                                              p_encoded_data,
    500                                              p_len);
   \   000000A0   0x9500             STR      R5,[SP, #+0]
   \   000000A2   0x0033             MOVS     R3,R6
   \   000000A4   0x2215             MOVS     R2,#+21
   \   000000A6   0x2114             MOVS     R1,#+20
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x3020             ADDS     R0,R0,#+32
   \   000000AC   0x.... 0x....      BL       uuid_list_encode
    501                  if (err_code != NRF_SUCCESS)
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD11E             BNE      ??adv_data_encode_1
    502                  {
    503                      return err_code;
    504                  }
    505              }
    506          
    507              // Encode Slave Connection Interval Range.
    508              if (p_advdata->p_slave_conn_int != NULL)
   \                     ??adv_data_encode_7: (+1)
   \   000000B4   0x6AA1             LDR      R1,[R4, #+40]
   \   000000B6   0x2900             CMP      R1,#+0
   \   000000B8   0xD006             BEQ      ??adv_data_encode_8
    509              {
    510                  err_code = conn_int_encode(p_advdata->p_slave_conn_int, p_encoded_data, p_len);
   \   000000BA   0x002A             MOVS     R2,R5
   \   000000BC   0x0031             MOVS     R1,R6
   \   000000BE   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C0   0x.... 0x....      BL       conn_int_encode
    511                  if (err_code != NRF_SUCCESS)
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD114             BNE      ??adv_data_encode_1
    512                  {
    513                      return err_code;
    514                  }
    515              }
    516          
    517              // Encode Manufacturer Specific Data.
    518              if (p_advdata->p_manuf_specific_data != NULL)
   \                     ??adv_data_encode_8: (+1)
   \   000000C8   0x6AE1             LDR      R1,[R4, #+44]
   \   000000CA   0x2900             CMP      R1,#+0
   \   000000CC   0xD006             BEQ      ??adv_data_encode_9
    519              {
    520                  err_code = manuf_specific_data_encode(p_advdata->p_manuf_specific_data,
    521                                                        p_encoded_data,
    522                                                        p_len);
   \   000000CE   0x002A             MOVS     R2,R5
   \   000000D0   0x0031             MOVS     R1,R6
   \   000000D2   0x6AE0             LDR      R0,[R4, #+44]
   \   000000D4   0x.... 0x....      BL       manuf_specific_data_encode
    523                  if (err_code != NRF_SUCCESS)
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD10A             BNE      ??adv_data_encode_1
    524                  {
    525                      return err_code;
    526                  }
    527              }
    528          
    529              // Encode Service Data.
    530              if (p_advdata->service_data_count > 0)
   \                     ??adv_data_encode_9: (+1)
   \   000000DC   0x2134             MOVS     R1,#+52
   \   000000DE   0x5C61             LDRB     R1,[R4, R1]
   \   000000E0   0x2900             CMP      R1,#+0
   \   000000E2   0xD006             BEQ      ??adv_data_encode_10
    531              {
    532                  err_code = service_data_encode(p_advdata, p_encoded_data, p_len);
   \   000000E4   0x002A             MOVS     R2,R5
   \   000000E6   0x0031             MOVS     R1,R6
   \   000000E8   0x0020             MOVS     R0,R4
   \   000000EA   0x.... 0x....      BL       service_data_encode
    533                  if (err_code != NRF_SUCCESS)
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD1FF             BNE      ??adv_data_encode_1
    534                  {
    535                      return err_code;
    536                  }
    537              }
    538          
    539              return err_code;
   \                     ??adv_data_encode_10: (+1)
   \                     ??adv_data_encode_1: (+1)
   \   000000F2   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    540          }
    541          
    542          

   \                                 In section .text, align 2, keep-with-next
    543          static uint32_t advdata_check(const ble_advdata_t * p_advdata)
    544          {
   \                     advdata_check: (+1)
   \   00000000   0xB500             PUSH     {LR}
    545              // Flags must be included in advertising data, and the BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED flag must be set.
    546              if ((p_advdata->flags.size == 0)      ||
    547                  (p_advdata->flags.p_data == NULL) ||
    548                  ((p_advdata->flags.p_data[0] & BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED) == 0)
    549                 )
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD006             BEQ      ??advdata_check_0
   \   00000008   0x6881             LDR      R1,[R0, #+8]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD003             BEQ      ??advdata_check_0
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x0740             LSLS     R0,R0,#+29
   \   00000014   0xD401             BMI      ??advdata_check_1
    550              {
    551                  return NRF_ERROR_INVALID_PARAM;
   \                     ??advdata_check_0: (+1)
   \   00000016   0x2007             MOVS     R0,#+7
   \   00000018   0xE000             B        ??advdata_check_2
    552              }
    553          
    554              return NRF_SUCCESS;
   \                     ??advdata_check_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??advdata_check_2: (+1)
   \   0000001C   0xBD00             POP      {PC}             ;; return
    555          }
    556          
    557          

   \                                 In section .text, align 2, keep-with-next
    558          static uint32_t srdata_check(const ble_advdata_t * p_srdata)
    559          {
   \                     srdata_check: (+1)
   \   00000000   0xB500             PUSH     {LR}
    560              // Flags shall not be included in the scan response data.
    561              if (p_srdata->flags.size > 0)
   \   00000002   0x8880             LDRH     R0,[R0, #+4]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ      ??srdata_check_0
    562              {
    563                  return NRF_ERROR_INVALID_PARAM;
   \   00000008   0x2007             MOVS     R0,#+7
   \   0000000A   0xE000             B        ??srdata_check_1
    564              }
    565          
    566              return NRF_SUCCESS;
   \                     ??srdata_check_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??srdata_check_1: (+1)
   \   0000000E   0xBD00             POP      {PC}             ;; return
    567          }
    568          
    569          

   \                                 In section .text, align 2, keep-with-next
    570          uint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata)
    571          {
   \                     ble_advdata_set: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB091             SUB      SP,SP,#+68
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    572              uint32_t  err_code;
    573              uint8_t   len_advdata = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x7048             STRB     R0,[R1, #+1]
    574              uint8_t   len_srdata  = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    575              uint8_t   encoded_advdata[BLE_GAP_ADV_MAX_SIZE];
    576              uint8_t   encoded_srdata[BLE_GAP_ADV_MAX_SIZE];
    577              uint8_t * p_encoded_advdata;
    578              uint8_t * p_encoded_srdata;
    579          
    580              // Encode advertising data (if supplied).
    581              if (p_advdata != NULL)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD00E             BEQ      ??ble_advdata_set_0
    582              {
    583                  err_code = advdata_check(p_advdata);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       advdata_check
    584                  if (err_code != NRF_SUCCESS)
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD121             BNE      ??ble_advdata_set_1
    585                  {
    586                      return err_code;
    587                  }
    588          
    589                  err_code = adv_data_encode(p_advdata, encoded_advdata, &len_advdata);
   \                     ??ble_advdata_set_2: (+1)
   \   00000022   0xAA00             ADD      R2,SP,#+0
   \   00000024   0x1C52             ADDS     R2,R2,#+1
   \   00000026   0xA909             ADD      R1,SP,#+36
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       adv_data_encode
    590                  if (err_code != NRF_SUCCESS)
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD119             BNE      ??ble_advdata_set_1
    591                  {
    592                      return err_code;
    593                  }
    594                  p_encoded_advdata = encoded_advdata;
   \                     ??ble_advdata_set_3: (+1)
   \   00000032   0xAC09             ADD      R4,SP,#+36
   \   00000034   0xE000             B        ??ble_advdata_set_4
    595              }
    596              else
    597              {
    598                  p_encoded_advdata = NULL;
   \                     ??ble_advdata_set_0: (+1)
   \   00000036   0x2400             MOVS     R4,#+0
    599              }
    600          
    601              // Encode scan response data (if supplied).
    602              if (p_srdata != NULL)
   \                     ??ble_advdata_set_4: (+1)
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD00D             BEQ      ??ble_advdata_set_5
    603              {
    604                  err_code = srdata_check(p_srdata);
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       srdata_check
    605                  if (err_code != NRF_SUCCESS)
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD10F             BNE      ??ble_advdata_set_1
    606                  {
    607                      return err_code;
    608                  }
    609          
    610                  err_code = adv_data_encode(p_srdata, encoded_srdata, &len_srdata);
   \                     ??ble_advdata_set_6: (+1)
   \   00000046   0x466A             MOV      R2,SP
   \   00000048   0xA901             ADD      R1,SP,#+4
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0x.... 0x....      BL       adv_data_encode
    611                  if (err_code != NRF_SUCCESS)
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD108             BNE      ??ble_advdata_set_1
    612                  {
    613                      return err_code;
    614                  }
    615                  p_encoded_srdata = encoded_srdata;
   \                     ??ble_advdata_set_7: (+1)
   \   00000054   0xAA01             ADD      R2,SP,#+4
   \   00000056   0xE000             B        ??ble_advdata_set_8
    616              }
    617              else
    618              {
    619                  p_encoded_srdata = NULL;
   \                     ??ble_advdata_set_5: (+1)
   \   00000058   0x2200             MOVS     R2,#+0
    620              }
    621          
    622              // Pass encoded advertising data and/or scan response data to the stack.
    623              return sd_ble_gap_adv_data_set(p_encoded_advdata, len_advdata, p_encoded_srdata, len_srdata);
   \                     ??ble_advdata_set_8: (+1)
   \   0000005A   0x4668             MOV      R0,SP
   \   0000005C   0x7803             LDRB     R3,[R0, #+0]
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x7841             LDRB     R1,[R0, #+1]
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0xDF72             SVC      0x72
   \                     ??ble_advdata_set_1: (+1)
   \   00000066   0xB011             ADD      SP,SP,#+68
   \   00000068   0xBD30             POP      {R4,R5,PC}       ;; return
    624          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x00000C81         DC32     0xc81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x0000FFFF         DC32     0xffff

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   adv_data_encode
        24   -> appearance_encode
        24   -> conn_int_encode
        24   -> manuf_specific_data_encode
        24   -> name_encode
        24   -> service_data_encode
        24   -> tx_power_level_encode
        24   -> uint8_array_encode
        24   -> uuid_list_encode
       4   advdata_check
      16   appearance_encode
        16   -> uint16_encode
      80   ble_advdata_set
        80   -> adv_data_encode
        80   -> advdata_check
        80   -> srdata_check
       4   conn_int_check
      16   conn_int_encode
        16   -> conn_int_check
        16   -> uint16_encode
      16   manuf_specific_data_encode
        16   -> __aeabi_memcpy
        16   -> uint16_encode
      24   name_encode
      32   service_data_encode
        32   -> __aeabi_memcpy
        32   -> uint16_encode
       4   srdata_check
       8   tx_power_level_encode
       0   uint16_encode
      16   uint8_array_encode
        16   -> __aeabi_memcpy
      24   uuid_list_encode
        24   -> uuid_list_sized_encode
      40   uuid_list_sized_encode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
     244  adv_data_encode
      30  advdata_check
      78  appearance_encode
     106  ble_advdata_set
      86  conn_int_check
      94  conn_int_encode
     114  manuf_specific_data_encode
     134  name_encode
     146  service_data_encode
      16  srdata_check
      58  tx_power_level_encode
      14  uint16_encode
      88  uint8_array_encode
      52  uuid_list_encode
     188  uuid_list_sized_encode

 
 1 456 bytes in section .text
 
 1 456 bytes of CODE memory

Errors: none
Warnings: none
