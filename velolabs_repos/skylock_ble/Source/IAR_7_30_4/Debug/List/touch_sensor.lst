###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        16/Apr/2015  21:19:51
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\VeloLabs\SkyLock Project\Source\touch_sensor.c
#    Command line =  
#        "C:\VeloLabs\SkyLock Project\Source\touch_sensor.c" -D NRF51 -D
#        BLE_STACK_SUPPORT_REQD -lCN "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\Debug\List\" -o "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\Debug\Obj\" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Normal.h" -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\include\" -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\include\ARMFiles\" -I
#        "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\drivers_nrf\hal\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\softdevice\s110\headers\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\toolchain\" -I
#        "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\softdevice\common\softdevice_handler\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\util\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\scheduler\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\libraries\timer\"
#        -I "C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\..\..\SDK_7_2_0\components\ble\common\" -Ol
#    List file    =  
#        C:\VeloLabs\SkyLock
#        Project\Source\IAR_7_30_4\Debug\List\touch_sensor.lst
#    Object file  =  
#        C:\VeloLabs\SkyLock Project\Source\IAR_7_30_4\Debug\Obj\touch_sensor.o
#
###############################################################################

C:\VeloLabs\SkyLock Project\Source\touch_sensor.c
      1          /*
      2          ** Proprietary Rights Notice
      3          **
      4          ** This material contains the valuable properties and trade secrets of:
      5          **
      6          **    Velo Labs
      7          **    San Francisco, CA, USA
      8          **
      9          ** All rights reserved. No part of this work may be reproduced, distributed, or
     10          ** transmitted in any form or by any means, including photocopying, recording,
     11          ** or other electronic or mechanical methods, without the prior written permission
     12          ** of Velo Labs.
     13          **
     14          ** Copyright (c) 2015, Velo Labs
     15          ** Contains Confidential and Trade Secret Information
     16          */
     17          
     18          /*
     19          ** File Name:  touch_sensor.c
     20          **
     21          ** Purpose:    Routines that support the capacitive touch interface and control the LED's
     22          */
     23          
     24          #include "master.h"
     25          #include "stdio.h"
     26          #include "string.h"
     27          #include "hardware.h"
     28          #include "i2c.h"
     29          

   \                                 In section .bss, align 1
     30          volatile uint8_t  TS_IRQCounter;
   \                     TS_IRQCounter:
   \   00000000                      DS8 1
     31          

   \                                 In section .rodata, align 4
     32          const unsigned char configMHD[9] = { TS_MHD_RISING, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0xFF, 0x02 };
   \                     configMHD:
   \   00000000   0x2B 0x01          DC8 43, 1, 1, 0, 0, 1, 1, 255, 2, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x01    
   \              0x01 0xFF    
   \              0x02 0x00    
   \              0x00 0x00    
     33          //const unsigned char configELE0[13] = { TS_ELE0_TOUCH, 0x06, 0x0A, 0x06, 0x0A, 0x06, 0x0A, 0x06, 0x0A, 0x06, 0x0A, 0x06, 0x0A };

   \                                 In section .rodata, align 4
     34          const unsigned char configELE0[13] = { TS_ELE0_TOUCH, 0x0F, 0x0A, 0x0F, 0x0A, 0x0F, 0x0A, 0x0F, 0x0A, 0x0F, 0x0A, 0x0F, 0x0A };
   \                     configELE0:
   \   00000000   0x41 0x0F          DC8 65, 15, 10, 15, 10, 15, 10, 15, 10, 15, 10, 15, 10, 0, 0, 0
   \              0x0A 0x0F    
   \              0x0A 0x0F    
   \              0x0A 0x0F    
   \              0x0A 0x0F    
   \              0x0A 0x0F    
   \              0x0A 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
     35          const unsigned char configAC[5] = { TS_AC_USL, 0xC9, 0x82, 0xB5 };
   \                     configAC:
   \   00000000   0x7D 0xC9          DC8 125, 201, 130, 181, 0, 0, 0, 0
   \              0x82 0xB5    
   \              0x00 0x00    
   \              0x00 0x00    
     36          //const unsigned char configE[2] = { TS_E_CONFIG, 0x06 };
     37          
     38          #define USER_PIN_LIMIT        (8)

   \                                 In section .rodata, align 4
     39          const uint8_t userNVPIN[4] = { 0x08, 0x10, 0x01, 0x04 };
   \                     userNVPIN:
   \   00000000   0x08 0x10          DC8 8, 16, 1, 4
   \              0x01 0x04    

   \                                 In section .data, align 1
     40          uint8_t userNVPINCount = 4;
   \                     userNVPINCount:
   \   00000000   0x04               DC8 4

   \                                 In section .bss, align 4
     41          uint8_t userPIN[USER_PIN_LIMIT];
   \                     userPIN:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
     42          uint8_t userPINCount;
   \                     userPINCount:
   \   00000000                      DS8 1
     43          
     44          /*
     45          ** Setup the touch sensor. This involves the following:
     46          **   #1). I2C address of touch sensor is 0x5A
     47          **   #2). Reset the touch sensor chip
     48          **   #3). Setup all LED's to OFF position
     49          **   #4).
     50          */

   \                                 In section .text, align 2, keep-with-next
     51          void
     52          TS_Setup (void)
     53          {
   \                     TS_Setup: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
     54             uint8_t data_byte[6];
     55          
     56                /* First send a reset command to the touch sensor chip */
     57             data_byte[0] = TS_SOFT_RESET_REG;
   \   00000004   0x2080             MOVS     R0,#+128
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x7008             STRB     R0,[R1, #+0]
     58             data_byte[1] = TS_SOFT_RESET_CMD;
   \   0000000A   0x2063             MOVS     R0,#+99
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7048             STRB     R0,[R1, #+1]
     59             I2C_Write (I2C_ADDR_TOUCH, data_byte, 2, TRUE);
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x205A             MOVS     R0,#+90
   \   00000018   0x.... 0x....      BL       I2C_Write
     60          
     61                /*
     62                ** Next, setup all the LED pins and turn them off
     63                ** ELE5 is not connected, so rig it to be an input with a pullup per AN3894.PDF
     64                */
     65             data_byte[0] = TS_GPIO_CTRL1;
   \   0000001C   0x2073             MOVS     R0,#+115
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x7008             STRB     R0,[R1, #+0]
     66             data_byte[1] = TS_ALL_LEDS;
   \   00000022   0x20FC             MOVS     R0,#+252
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x7048             STRB     R0,[R1, #+1]
     67             data_byte[2] = TS_ALL_LEDS;
   \   00000028   0x20FC             MOVS     R0,#+252
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x7088             STRB     R0,[R1, #+2]
     68             data_byte[3] = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x70C8             STRB     R0,[R1, #+3]
     69             data_byte[4] = TS_ALL_LEDS;
   \   00000034   0x20FC             MOVS     R0,#+252
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x7108             STRB     R0,[R1, #+4]
     70             data_byte[5] = TS_ALL_LEDS | TS_UNUSED_ELE5;
   \   0000003A   0x20FE             MOVS     R0,#+254
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x7148             STRB     R0,[R1, #+5]
     71             I2C_Write (I2C_ADDR_TOUCH, data_byte, 6, TRUE);
   \   00000040   0x2301             MOVS     R3,#+1
   \   00000042   0x2206             MOVS     R2,#+6
   \   00000044   0x4669             MOV      R1,SP
   \   00000046   0x205A             MOVS     R0,#+90
   \   00000048   0x.... 0x....      BL       I2C_Write
     72          
     73                /*
     74                ** Configuration the sensors. The default setting currently is from Freescale and
     75                ** document AN3944.
     76                */
     77             I2C_Write (I2C_ADDR_TOUCH, configMHD, 9, TRUE);
   \   0000004C   0x2301             MOVS     R3,#+1
   \   0000004E   0x2209             MOVS     R2,#+9
   \   00000050   0x....             LDR      R1,??DataTable1
   \   00000052   0x205A             MOVS     R0,#+90
   \   00000054   0x.... 0x....      BL       I2C_Write
     78             I2C_Write (I2C_ADDR_TOUCH, configELE0, 13, TRUE);
   \   00000058   0x2301             MOVS     R3,#+1
   \   0000005A   0x220D             MOVS     R2,#+13
   \   0000005C   0x....             LDR      R1,??DataTable1_1
   \   0000005E   0x205A             MOVS     R0,#+90
   \   00000060   0x.... 0x....      BL       I2C_Write
     79          
     80                /* Set sample rate to 64 milliseconds */
     81             data_byte[0] = TS_FILTER_CFG;
   \   00000064   0x205D             MOVS     R0,#+93
   \   00000066   0x4669             MOV      R1,SP
   \   00000068   0x7008             STRB     R0,[R1, #+0]
     82             data_byte[1] = 0x06;
   \   0000006A   0x2006             MOVS     R0,#+6
   \   0000006C   0x4669             MOV      R1,SP
   \   0000006E   0x7048             STRB     R0,[R1, #+1]
     83             I2C_Write (I2C_ADDR_TOUCH, data_byte, 2, TRUE);
   \   00000070   0x2301             MOVS     R3,#+1
   \   00000072   0x2202             MOVS     R2,#+2
   \   00000074   0x4669             MOV      R1,SP
   \   00000076   0x205A             MOVS     R0,#+90
   \   00000078   0x.... 0x....      BL       I2C_Write
     84          
     85             data_byte[0] = TS_AC_CTRL0;
   \   0000007C   0x207B             MOVS     R0,#+123
   \   0000007E   0x4669             MOV      R1,SP
   \   00000080   0x7008             STRB     R0,[R1, #+0]
     86             data_byte[1] = 0x0B;
   \   00000082   0x200B             MOVS     R0,#+11
   \   00000084   0x4669             MOV      R1,SP
   \   00000086   0x7048             STRB     R0,[R1, #+1]
     87             I2C_Write (I2C_ADDR_TOUCH, data_byte, 2, TRUE);
   \   00000088   0x2301             MOVS     R3,#+1
   \   0000008A   0x2202             MOVS     R2,#+2
   \   0000008C   0x4669             MOV      R1,SP
   \   0000008E   0x205A             MOVS     R0,#+90
   \   00000090   0x.... 0x....      BL       I2C_Write
     88          
     89             I2C_Write (I2C_ADDR_TOUCH, configAC, 4, TRUE);
   \   00000094   0x2301             MOVS     R3,#+1
   \   00000096   0x2204             MOVS     R2,#+4
   \   00000098   0x....             LDR      R1,??DataTable1_2
   \   0000009A   0x205A             MOVS     R0,#+90
   \   0000009C   0x.... 0x....      BL       I2C_Write
     90          //   I2C_Write (I2C_ADDR_TOUCH, configE, 2, TRUE);
     91          
     92             data_byte[0] = TS_E_CONFIG;
   \   000000A0   0x205E             MOVS     R0,#+94
   \   000000A2   0x4669             MOV      R1,SP
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
     93             data_byte[1] = 0x06 | 0x80;
   \   000000A6   0x2086             MOVS     R0,#+134
   \   000000A8   0x4669             MOV      R1,SP
   \   000000AA   0x7048             STRB     R0,[R1, #+1]
     94             I2C_Write (I2C_ADDR_TOUCH, data_byte, 2, TRUE);
   \   000000AC   0x2301             MOVS     R3,#+1
   \   000000AE   0x2202             MOVS     R2,#+2
   \   000000B0   0x4669             MOV      R1,SP
   \   000000B2   0x205A             MOVS     R0,#+90
   \   000000B4   0x.... 0x....      BL       I2C_Write
     95          
     96                /*
     97                ** Setup IRQ pin to let us know when there is a button press by the user. The IRQ pin is active low
     98                ** and it will clear when we read the status register.
     99                */
    100             NRF_GPIO->PIN_CNF[MPR121_IRQ] =
    101                      (GPIO_PIN_CNF_DIR_Input      << GPIO_PIN_CNF_DIR_Pos)
    102                    | (GPIO_PIN_CNF_INPUT_Connect  << GPIO_PIN_CNF_INPUT_Pos)
    103                    | (GPIO_PIN_CNF_PULL_Disabled  << GPIO_PIN_CNF_PULL_Pos)
    104                    | (GPIO_PIN_CNF_DRIVE_S0D1     << GPIO_PIN_CNF_DRIVE_Pos)
    105                    | (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos);
   \   000000B8   0x20C0             MOVS     R0,#+192
   \   000000BA   0x00C0             LSLS     R0,R0,#+3        ;; #+1536
   \   000000BC   0x....             LDR      R1,??DataTable1_3  ;; 0x50000724
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    106          
    107             NRF_GPIOTE->CONFIG[2] =
    108                      (GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos)
    109                    | (MPR121_IRQ << GPIOTE_CONFIG_PSEL_Pos)
    110                    | (GPIOTE_CONFIG_POLARITY_HiToLo << GPIOTE_CONFIG_POLARITY_Pos);
   \   000000C0   0x....             LDR      R0,??DataTable1_4  ;; 0x20901
   \   000000C2   0x....             LDR      R1,??DataTable1_5  ;; 0x40006518
   \   000000C4   0x6008             STR      R0,[R1, #+0]
    111          
    112             NRF_GPIOTE->INTENSET |= GPIOTE_INTENSET_IN2_Msk;
   \   000000C6   0x....             LDR      R0,??DataTable1_6  ;; 0x40006304
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0x2104             MOVS     R1,#+4
   \   000000CC   0x4301             ORRS     R1,R1,R0
   \   000000CE   0x....             LDR      R0,??DataTable1_6  ;; 0x40006304
   \   000000D0   0x6001             STR      R1,[R0, #+0]
    113          
    114             data_byte[0] = TS_GPIO_DATA;
   \   000000D2   0x2075             MOVS     R0,#+117
   \   000000D4   0x4669             MOV      R1,SP
   \   000000D6   0x7008             STRB     R0,[R1, #+0]
    115             I2C_Write (I2C_ADDR_TOUCH, data_byte, 1, FALSE);
   \   000000D8   0x2300             MOVS     R3,#+0
   \   000000DA   0x2201             MOVS     R2,#+1
   \   000000DC   0x4669             MOV      R1,SP
   \   000000DE   0x205A             MOVS     R0,#+90
   \   000000E0   0x.... 0x....      BL       I2C_Write
    116             I2C_Read (I2C_ADDR_TOUCH, &data_byte[1], 2);
   \   000000E4   0x2202             MOVS     R2,#+2
   \   000000E6   0x4669             MOV      R1,SP
   \   000000E8   0x1C49             ADDS     R1,R1,#+1
   \   000000EA   0x205A             MOVS     R0,#+90
   \   000000EC   0x.... 0x....      BL       I2C_Read
    117          }
   \   000000F0   0xBD07             POP      {R0-R2,PC}       ;; return
    118          
    119          /*
    120          ** For now, a simple little function that will keep 1 LED active and will rotate the LED through
    121          ** all the possible choices.
    122          */

   \                                 In section .text, align 2, keep-with-next
    123          void
    124          TS_ToggleTestLED (void)
    125          {
   \                     TS_ToggleTestLED: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    126             uint8_t data_byte[6];
    127          
    128             data_byte[0] = TS_GPIO_DATA;
   \   00000004   0x2075             MOVS     R0,#+117
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    129             I2C_Write (I2C_ADDR_TOUCH, data_byte, 1, FALSE);
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x205A             MOVS     R0,#+90
   \   00000012   0x.... 0x....      BL       I2C_Write
    130             I2C_Read (I2C_ADDR_TOUCH, &data_byte[1], 2);
   \   00000016   0x2202             MOVS     R2,#+2
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0x205A             MOVS     R0,#+90
   \   0000001E   0x.... 0x....      BL       I2C_Read
    131          
    132             data_byte[1] <<= 1;
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x7840             LDRB     R0,[R0, #+1]
   \   00000026   0x0040             LSLS     R0,R0,#+1
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x7048             STRB     R0,[R1, #+1]
    133             if (!data_byte[1])
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x7840             LDRB     R0,[R0, #+1]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD102             BNE      ??TS_ToggleTestLED_0
    134                data_byte[1] = TS_FIRST_LED;
   \   00000034   0x2004             MOVS     R0,#+4
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x7048             STRB     R0,[R1, #+1]
    135          
    136             I2C_Write (I2C_ADDR_TOUCH, data_byte, 2, TRUE);
   \                     ??TS_ToggleTestLED_0: (+1)
   \   0000003A   0x2301             MOVS     R3,#+1
   \   0000003C   0x2202             MOVS     R2,#+2
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x205A             MOVS     R0,#+90
   \   00000042   0x.... 0x....      BL       I2C_Write
    137          }
   \   00000046   0xBD07             POP      {R0-R2,PC}       ;; return
    138          
    139          /*
    140          ** Should be able to just implement this using the Toggle command. Although testing has shown that
    141          ** the first call to this routine does not work. Tried extra calls during the initialization routine
    142          ** and nothing seems to work. Have also let the system set for minutes and then made the first call
    143          ** to Toggle and it also doesn't work. On the second call it then works just fine.
    144          **
    145          ** What does work is reading back the current settings and then sending the Toggle command.
    146          ** At this point, might as well just do the toggle ourselves then.
    147          */

   \                                 In section .text, align 2, keep-with-next
    148          uint8_t
    149          TS_ToggleLED (uint8_t led)
    150          {
   \                     TS_ToggleLED: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    151             uint8_t data_byte[3];
    152          
    153             data_byte[0] = TS_GPIO_DATA;
   \   00000006   0x2075             MOVS     R0,#+117
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    154             I2C_Write (I2C_ADDR_TOUCH, data_byte, 1, FALSE);
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x205A             MOVS     R0,#+90
   \   00000014   0x.... 0x....      BL       I2C_Write
    155             I2C_Read (I2C_ADDR_TOUCH, &data_byte[2], 1);
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x1C89             ADDS     R1,R1,#+2
   \   0000001E   0x205A             MOVS     R0,#+90
   \   00000020   0x.... 0x....      BL       I2C_Read
    156          
    157             data_byte[1] = (data_byte[2] ^ led) & TS_ALL_LEDS;
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x7880             LDRB     R0,[R0, #+2]
   \   00000028   0x4044             EORS     R4,R4,R0
   \   0000002A   0x20FC             MOVS     R0,#+252
   \   0000002C   0x4020             ANDS     R0,R0,R4
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x7048             STRB     R0,[R1, #+1]
    158             I2C_Write (I2C_ADDR_TOUCH, data_byte, 2, TRUE);
   \   00000032   0x2301             MOVS     R3,#+1
   \   00000034   0x2202             MOVS     R2,#+2
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x205A             MOVS     R0,#+90
   \   0000003A   0x.... 0x....      BL       I2C_Write
    159          
    160             data_byte[0] = TS_GPIO_DATA;
   \   0000003E   0x2075             MOVS     R0,#+117
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x7008             STRB     R0,[R1, #+0]
    161             I2C_Write (I2C_ADDR_TOUCH, data_byte, 1, FALSE);
   \   00000044   0x2300             MOVS     R3,#+0
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x205A             MOVS     R0,#+90
   \   0000004C   0x.... 0x....      BL       I2C_Write
    162             I2C_Read (I2C_ADDR_TOUCH, &data_byte[1], 1);
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0x4669             MOV      R1,SP
   \   00000054   0x1C49             ADDS     R1,R1,#+1
   \   00000056   0x205A             MOVS     R0,#+90
   \   00000058   0x.... 0x....      BL       I2C_Read
    163          
    164             return (data_byte[1]);
   \   0000005C   0x4668             MOV      R0,SP
   \   0000005E   0x7840             LDRB     R0,[R0, #+1]
   \   00000060   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    165          }
    166          
    167          /*
    168          ** Ran into a similar problem with this function. Found some cases where I called this and nothing happened
    169          ** and then the next call it worked. Found that adding a read seemed to help
    170          */

   \                                 In section .text, align 2, keep-with-next
    171          void
    172          TS_SetLED(uint8_t led)
    173          {
   \                     TS_SetLED: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    174             uint8_t data_byte[6];
    175          
    176             data_byte[0] = TS_GPIO_DATA;
   \   00000004   0x2075             MOVS     R0,#+117
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    177             I2C_Write (I2C_ADDR_TOUCH, data_byte, 1, FALSE);
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x205A             MOVS     R0,#+90
   \   00000012   0x.... 0x....      BL       I2C_Write
    178             I2C_Read (I2C_ADDR_TOUCH, &data_byte[2], 1);
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x1C89             ADDS     R1,R1,#+2
   \   0000001C   0x205A             MOVS     R0,#+90
   \   0000001E   0x.... 0x....      BL       I2C_Read
    179          
    180             data_byte[1] = led & TS_ALL_LEDS;
   \   00000022   0x20FC             MOVS     R0,#+252
   \   00000024   0x4020             ANDS     R0,R0,R4
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x7048             STRB     R0,[R1, #+1]
    181             I2C_Write (I2C_ADDR_TOUCH, data_byte, 2, TRUE);
   \   0000002A   0x2301             MOVS     R3,#+1
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x205A             MOVS     R0,#+90
   \   00000032   0x.... 0x....      BL       I2C_Write
    182          }
   \   00000036   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    183          
    184          /*
    185          ** This routine will read in the touch button status and will match an LED
    186          ** to each button that is lit. The idea is to keep the LED lit while the button
    187          ** is pushed. So a routine somewhere else will notice the touch interrupt
    188          ** has been called and will then call this routine to then do something
    189          ** about it.
    190          **
    191          ** If lockActive is TRUE then implement the logic for capturing a PIN sequence
    192          ** If user enters a valid value then return TRUE, otherwise return FALSE.
    193          */

   \                                 In section .text, align 2, keep-with-next
    194          uint8_t
    195          TS_TouchLED (bool lockActive)
    196          {
   \                     TS_TouchLED: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0006             MOVS     R6,R0
    197             uint8_t buffer[3];
    198             uint8_t led_state = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    199             uint8_t status = FALSE;
   \   00000008   0x2500             MOVS     R5,#+0
    200          
    201                /* Fetch the state of the buttons */
    202             buffer[0] = TS_TOUCH_STATUS;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    203             I2C_Write (I2C_ADDR_TOUCH, buffer, 1, FALSE);
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x205A             MOVS     R0,#+90
   \   00000018   0x.... 0x....      BL       I2C_Write
    204             I2C_Read (I2C_ADDR_TOUCH, &buffer[1], 2);
   \   0000001C   0x2202             MOVS     R2,#+2
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x1C49             ADDS     R1,R1,#+1
   \   00000022   0x205A             MOVS     R0,#+90
   \   00000024   0x.... 0x....      BL       I2C_Read
    205          
    206             buffer[1] &= TS_SENSOR_MASK;
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x7840             LDRB     R0,[R0, #+1]
   \   0000002C   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   0000002E   0x0EC0             LSRS     R0,R0,#+27
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x7048             STRB     R0,[R1, #+1]
    207             if (buffer[1])
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x7840             LDRB     R0,[R0, #+1]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD022             BEQ      ??TS_TouchLED_0
    208                {
    209                if (buffer[1] & TS_ELE0)
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x7840             LDRB     R0,[R0, #+1]
   \   00000040   0x07C0             LSLS     R0,R0,#+31
   \   00000042   0xD502             BPL      ??TS_TouchLED_1
    210                   led_state |= TS_LED1;
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x2404             MOVS     R4,#+4
   \   00000048   0x4304             ORRS     R4,R4,R0
    211          
    212                if (buffer[1] & TS_ELE1)
   \                     ??TS_TouchLED_1: (+1)
   \   0000004A   0x4668             MOV      R0,SP
   \   0000004C   0x7840             LDRB     R0,[R0, #+1]
   \   0000004E   0x0780             LSLS     R0,R0,#+30
   \   00000050   0xD502             BPL      ??TS_TouchLED_2
    213                   led_state |= TS_LED6;
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x2480             MOVS     R4,#+128
   \   00000056   0x4304             ORRS     R4,R4,R0
    214          
    215                if (buffer[1] & TS_ELE2)
   \                     ??TS_TouchLED_2: (+1)
   \   00000058   0x4668             MOV      R0,SP
   \   0000005A   0x7840             LDRB     R0,[R0, #+1]
   \   0000005C   0x0740             LSLS     R0,R0,#+29
   \   0000005E   0xD502             BPL      ??TS_TouchLED_3
    216                   led_state |= TS_LED3;
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x2410             MOVS     R4,#+16
   \   00000064   0x4304             ORRS     R4,R4,R0
    217          
    218                if (buffer[1] & TS_ELE3)
   \                     ??TS_TouchLED_3: (+1)
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0x7840             LDRB     R0,[R0, #+1]
   \   0000006A   0x0700             LSLS     R0,R0,#+28
   \   0000006C   0xD502             BPL      ??TS_TouchLED_4
    219                   led_state |= TS_LED4;
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x2420             MOVS     R4,#+32
   \   00000072   0x4304             ORRS     R4,R4,R0
    220          
    221                if (buffer[1] & TS_ELE4)
   \                     ??TS_TouchLED_4: (+1)
   \   00000074   0x4668             MOV      R0,SP
   \   00000076   0x7840             LDRB     R0,[R0, #+1]
   \   00000078   0x06C0             LSLS     R0,R0,#+27
   \   0000007A   0xD502             BPL      ??TS_TouchLED_0
    222                   led_state |= TS_LED5;
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x2440             MOVS     R4,#+64
   \   00000080   0x4304             ORRS     R4,R4,R0
    223                }
    224          
    225                /* Always set the LED's when this is called */
    226             TS_SetLED (led_state);
   \                     ??TS_TouchLED_0: (+1)
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0xB2C0             UXTB     R0,R0
   \   00000086   0x.... 0x....      BL       TS_SetLED
    227          
    228             if (lockActive)
   \   0000008A   0xB2F6             UXTB     R6,R6
   \   0000008C   0x2E00             CMP      R6,#+0
   \   0000008E   0xD037             BEQ      ??TS_TouchLED_5
    229                {
    230                   /*
    231                   ** For now, only take single button presses. Ignore any multiple button presses and don't punish.
    232                   ** I don't know if we want to punish on multiple pushes or not. Something to discuss.
    233                   */
    234                if (   (buffer[1] == TS_ELE0)
    235                    || (buffer[1] == TS_ELE2)
    236                    || (buffer[1] == TS_ELE3)
    237                    || (buffer[1] == TS_ELE4))
   \   00000090   0x4668             MOV      R0,SP
   \   00000092   0x7840             LDRB     R0,[R0, #+1]
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD00B             BEQ      ??TS_TouchLED_6
   \   00000098   0x4668             MOV      R0,SP
   \   0000009A   0x7840             LDRB     R0,[R0, #+1]
   \   0000009C   0x2804             CMP      R0,#+4
   \   0000009E   0xD007             BEQ      ??TS_TouchLED_6
   \   000000A0   0x4668             MOV      R0,SP
   \   000000A2   0x7840             LDRB     R0,[R0, #+1]
   \   000000A4   0x2808             CMP      R0,#+8
   \   000000A6   0xD003             BEQ      ??TS_TouchLED_6
   \   000000A8   0x4668             MOV      R0,SP
   \   000000AA   0x7840             LDRB     R0,[R0, #+1]
   \   000000AC   0x2810             CMP      R0,#+16
   \   000000AE   0xD10E             BNE      ??TS_TouchLED_7
    238                   {
    239                   if (userPINCount < USER_PIN_LIMIT)
   \                     ??TS_TouchLED_6: (+1)
   \   000000B0   0x....             LDR      R0,??DataTable1_7
   \   000000B2   0x7800             LDRB     R0,[R0, #+0]
   \   000000B4   0x2808             CMP      R0,#+8
   \   000000B6   0xDA0A             BGE      ??TS_TouchLED_7
    240                      {
    241                      userPIN[userPINCount] = buffer[1];
   \   000000B8   0x4668             MOV      R0,SP
   \   000000BA   0x7840             LDRB     R0,[R0, #+1]
   \   000000BC   0x....             LDR      R1,??DataTable1_8
   \   000000BE   0x....             LDR      R2,??DataTable1_7
   \   000000C0   0x7812             LDRB     R2,[R2, #+0]
   \   000000C2   0x5488             STRB     R0,[R1, R2]
    242                      userPINCount++;
   \   000000C4   0x....             LDR      R0,??DataTable1_7
   \   000000C6   0x7800             LDRB     R0,[R0, #+0]
   \   000000C8   0x1C40             ADDS     R0,R0,#+1
   \   000000CA   0x....             LDR      R1,??DataTable1_7
   \   000000CC   0x7008             STRB     R0,[R1, #+0]
    243                      }
    244                   }
    245          
    246                   /*
    247                   ** Did user press the center button? If so then check the PIN entered. If good, toggle
    248                   ** lock. In either case, clear the PIN and start over looking for a password again.
    249                   */
    250                if (buffer[1] == TS_ELE1)
   \                     ??TS_TouchLED_7: (+1)
   \   000000CE   0x4668             MOV      R0,SP
   \   000000D0   0x7840             LDRB     R0,[R0, #+1]
   \   000000D2   0x2802             CMP      R0,#+2
   \   000000D4   0xD114             BNE      ??TS_TouchLED_5
    251                   {
    252                   if ((userNVPINCount == userPINCount) && !(memcmp (userNVPIN, userPIN, userNVPINCount)))
   \   000000D6   0x....             LDR      R0,??DataTable1_9
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x....             LDR      R1,??DataTable1_7
   \   000000DC   0x7809             LDRB     R1,[R1, #+0]
   \   000000DE   0x4288             CMP      R0,R1
   \   000000E0   0xD10B             BNE      ??TS_TouchLED_8
   \   000000E2   0x....             LDR      R0,??DataTable1_9
   \   000000E4   0x7802             LDRB     R2,[R0, #+0]
   \   000000E6   0x....             LDR      R1,??DataTable1_8
   \   000000E8   0x....             LDR      R0,??DataTable1_10
   \   000000EA   0x.... 0x....      BL       memcmp
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD103             BNE      ??TS_TouchLED_8
    253                      {
    254                      printf("Lock sequence is good!\n");
   \   000000F2   0x....             LDR      R0,??DataTable1_11
   \   000000F4   0x.... 0x....      BL       printf
    255                      status = TRUE;
   \   000000F8   0x2501             MOVS     R5,#+1
    256                      }
    257          
    258                   userPINCount = 0;
   \                     ??TS_TouchLED_8: (+1)
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x....             LDR      R1,??DataTable1_7
   \   000000FE   0x7008             STRB     R0,[R1, #+0]
    259                   }
    260                }
    261          
    262             return (status);
   \                     ??TS_TouchLED_5: (+1)
   \   00000100   0x0028             MOVS     R0,R5
   \   00000102   0xB2C0             UXTB     R0,R0
   \   00000104   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    263          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     configMHD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     configELE0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     configAC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x50000724         DC32     0x50000724

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x00020901         DC32     0x20901

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x40006518         DC32     0x40006518

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   0x40006304         DC32     0x40006304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \   00000000   0x........         DC32     userPINCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \   00000000   0x........         DC32     userPIN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_9:
   \   00000000   0x........         DC32     userNVPINCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_10:
   \   00000000   0x........         DC32     userNVPIN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_11:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x4C 0x6F          DC8 "Lock sequence is good!\012"
   \              0x63 0x6B    
   \              0x20 0x73    
   \              0x65 0x71    
   \              0x75 0x65    
   \              0x6E 0x63    
   \              0x65 0x20    
   \              0x69 0x73    
   \              0x20 0x67    
   \              0x6F 0x6F    
   \              0x64 0x21    
   \              0x0A 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TS_SetLED
        16   -> I2C_Read
        16   -> I2C_Write
      16   TS_Setup
        16   -> I2C_Read
        16   -> I2C_Write
      16   TS_ToggleLED
        16   -> I2C_Read
        16   -> I2C_Write
      16   TS_ToggleTestLED
        16   -> I2C_Read
        16   -> I2C_Write
      24   TS_TouchLED
        24   -> I2C_Read
        24   -> I2C_Write
        24   -> TS_SetLED
        24   -> memcmp
        24   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
      24  ?_0
       1  TS_IRQCounter
      56  TS_SetLED
     242  TS_Setup
      98  TS_ToggleLED
      72  TS_ToggleTestLED
     262  TS_TouchLED
       8  configAC
      16  configELE0
      12  configMHD
       4  userNVPIN
       1  userNVPINCount
       8  userPIN
       1  userPINCount

 
  10 bytes in section .bss
   1 byte  in section .data
  64 bytes in section .rodata
 778 bytes in section .text
 
 778 bytes of CODE  memory
  64 bytes of CONST memory
  11 bytes of DATA  memory

Errors: none
Warnings: none
